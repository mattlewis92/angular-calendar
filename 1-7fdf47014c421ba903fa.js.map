{"version":3,"sources":["webpack:///1-7fdf47014c421ba903fa.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/observable/concat.js","webpack:///./node_modules/rxjs/observable/fromEvent.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/operators/debounceTime.js","webpack:///./node_modules/rxjs/operators/tap.js","webpack:///./node_modules/rxjs/operators/combineLatest.js","webpack:///./node_modules/rxjs/operators/find.js","webpack:///./node_modules/rxjs/ReplaySubject.js","webpack:///./node_modules/rxjs/operators/switchMap.js","webpack:///./node_modules/rxjs/operators/zip.js","webpack:///./node_modules/rxjs/observable/FromEventObservable.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/operators.js","webpack:///./node_modules/rxjs/operators/buffer.js","webpack:///./node_modules/rxjs/operators/bufferCount.js","webpack:///./node_modules/rxjs/operators/bufferTime.js","webpack:///./node_modules/rxjs/operators/bufferToggle.js","webpack:///./node_modules/rxjs/operators/bufferWhen.js","webpack:///./node_modules/rxjs/operators/combineAll.js","webpack:///./node_modules/rxjs/operators/concat.js","webpack:///./node_modules/rxjs/operators/concatMapTo.js","webpack:///./node_modules/rxjs/operators/count.js","webpack:///./node_modules/rxjs/operators/debounce.js","webpack:///./node_modules/rxjs/operators/delay.js","webpack:///./node_modules/rxjs/operators/delayWhen.js","webpack:///./node_modules/rxjs/operators/dematerialize.js","webpack:///./node_modules/rxjs/operators/distinct.js","webpack:///./node_modules/rxjs/util/Set.js","webpack:///./node_modules/rxjs/operators/distinctUntilKeyChanged.js","webpack:///./node_modules/rxjs/operators/elementAt.js","webpack:///./node_modules/rxjs/operators/exhaust.js","webpack:///./node_modules/rxjs/operators/exhaustMap.js","webpack:///./node_modules/rxjs/operators/expand.js","webpack:///./node_modules/rxjs/operators/finalize.js","webpack:///./node_modules/rxjs/operators/findIndex.js","webpack:///./node_modules/rxjs/operators/groupBy.js","webpack:///./node_modules/rxjs/util/Map.js","webpack:///./node_modules/rxjs/util/MapPolyfill.js","webpack:///./node_modules/rxjs/util/FastMap.js","webpack:///./node_modules/rxjs/operators/ignoreElements.js","webpack:///./node_modules/rxjs/operators/isEmpty.js","webpack:///./node_modules/rxjs/operators/mapTo.js","webpack:///./node_modules/rxjs/operators/materialize.js","webpack:///./node_modules/rxjs/operators/max.js","webpack:///./node_modules/rxjs/operators/merge.js","webpack:///./node_modules/rxjs/operators/mergeMapTo.js","webpack:///./node_modules/rxjs/operators/mergeScan.js","webpack:///./node_modules/rxjs/operators/min.js","webpack:///./node_modules/rxjs/operators/onErrorResumeNext.js","webpack:///./node_modules/rxjs/operators/partition.js","webpack:///./node_modules/rxjs/util/not.js","webpack:///./node_modules/rxjs/operators/pluck.js","webpack:///./node_modules/rxjs/operators/publish.js","webpack:///./node_modules/rxjs/operators/publishBehavior.js","webpack:///./node_modules/rxjs/operators/publishLast.js","webpack:///./node_modules/rxjs/AsyncSubject.js","webpack:///./node_modules/rxjs/operators/publishReplay.js","webpack:///./node_modules/rxjs/scheduler/queue.js","webpack:///./node_modules/rxjs/scheduler/QueueAction.js","webpack:///./node_modules/rxjs/scheduler/QueueScheduler.js","webpack:///./node_modules/rxjs/operators/race.js","webpack:///./node_modules/rxjs/observable/race.js","webpack:///./node_modules/rxjs/operators/repeat.js","webpack:///./node_modules/rxjs/operators/repeatWhen.js","webpack:///./node_modules/rxjs/operators/retry.js","webpack:///./node_modules/rxjs/operators/retryWhen.js","webpack:///./node_modules/rxjs/operators/sample.js","webpack:///./node_modules/rxjs/operators/sampleTime.js","webpack:///./node_modules/rxjs/operators/sequenceEqual.js","webpack:///./node_modules/rxjs/operators/shareReplay.js","webpack:///./node_modules/rxjs/operators/single.js","webpack:///./node_modules/rxjs/operators/skip.js","webpack:///./node_modules/rxjs/operators/skipLast.js","webpack:///./node_modules/rxjs/operators/skipUntil.js","webpack:///./node_modules/rxjs/operators/skipWhile.js","webpack:///./node_modules/rxjs/operators/startWith.js","webpack:///./node_modules/rxjs/operators/switchAll.js","webpack:///./node_modules/rxjs/operators/switchMapTo.js","webpack:///./node_modules/rxjs/operators/takeWhile.js","webpack:///./node_modules/rxjs/operators/throttleTime.js","webpack:///./node_modules/rxjs/operators/timeInterval.js","webpack:///./node_modules/rxjs/operators/timeout.js","webpack:///./node_modules/rxjs/util/TimeoutError.js","webpack:///./node_modules/rxjs/operators/timeoutWith.js","webpack:///./node_modules/rxjs/operators/timestamp.js","webpack:///./node_modules/rxjs/operators/toArray.js","webpack:///./node_modules/rxjs/operators/window.js","webpack:///./node_modules/rxjs/operators/windowCount.js","webpack:///./node_modules/rxjs/operators/windowTime.js","webpack:///./node_modules/rxjs/operators/windowToggle.js","webpack:///./node_modules/rxjs/operators/windowWhen.js","webpack:///./node_modules/rxjs/operators/withLatestFrom.js","webpack:///./node_modules/rxjs/operators/zipAll.js"],"names":["webpackJsonp","645","module","__webpack_exports__","__webpack_require__","supportsPassiveEventListeners","supportsPassiveEvents","window","addEventListener","Object","defineProperty","get","SCROLL_DISPATCHER_PROVIDER_FACTORY","parentDispatcher","ngZone","platform","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrolling_es5_ViewportRuler","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalOutletError","throwNoPortalAttachedError","coerceBooleanProperty","value","getMatScrollStrategyAlreadyAttachedError","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","formatCssUnit","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","_document","overlay_es5_OverlayKeyboardDispatcher","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","getFrameElement","e","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","getAttribute","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","match","ARIA_DESCRIBER_PROVIDER_FACTORY","a11y_es5_AriaDescriber","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","klass","ngClass","ngForOf","menuClass","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","calendar_tooltip_directive","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","DemoModule","calendar_tooltip_directive_ngfactory","hasV8BreakIterator","Intl","v8BreakIterator","platform_es5_Platform","Platform","this","isBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","args","providers","Subject","Observable","of","fromEvent","auditTime","merge","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","prototype","register","scrollable","_this","scrollSubscription","elementScrolled","subscribe","next","set","deregister","scrollableReference","unsubscribe","delete","scrolled","auditTimeInMs","create","observer","_addGlobalListener","subscription","pipe","_removeGlobalListener","ngOnDestroy","forEach","_","container","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","indexOf","scrollingContainers","_subscription","_scrollableContainsElement","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","SCROLL_DISPATCHER_PROVIDER","provide","deps","useFactory","scrolling_es5_CdkScrollable","CdkScrollable","_elementRef","_scroll","_elementScrolled","_scrollListener","ngOnInit","removeEventListener","asObservable","selector","ViewportRuler","_change","_invalidateCache","change","_updateViewportSize","getViewportSize","_viewportSize","output","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","_a","documentRect","documentElement","getBoundingClientRect","body","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","imports","exports","declarations","DIR_DOCUMENT","bidi_es5_Directionality","Directionality","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","v","old","enumerable","configurable","ngAfterContentInit","complete","useExisting","host","[dir]","exportAs","propDecorators","bidi_es5_BidiModule","BidiModule","tslib_es6","Portal","attach","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","_super","ComponentPortal","viewContainerRef","injector","call","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","portal_es5_DomPortalOutlet","DomPortalOutlet","outletElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","destroy","attachView","hostView","detachView","appendChild","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","index","remove","parentNode","removeChild","portal_es5_CdkPortal","CdkPortal","portal_es5_CdkPortalOutlet","CdkPortalOutlet","_viewContainerRef","attached","_attachedRef","ref","clear","inputs","_deprecatedPortal","_deprecatedPortalHost","portal_es5_PortalModule","PortalModule","take","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","Subscription","NoopScrollStrategy","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","key","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","CloseScrollStrategy","_scrollDispatcher","_viewportRuler","_config","_scrollSubscription","_detach","_overlayRef","run","overlayRef","stream","threshold","_initialScrollPosition","Math","abs","updatePosition","BlockScrollStrategy","_previousHTMLStyles","_isEnabled","_canBeEnabled","root","_previousScrollPosition","style","classList","add","html","previousHtmlScrollBehavior","previousBodyScrollBehavior","scroll","contains","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","throttle","scrollThrottle","autoClose","overlayRect","overlayElement","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","overlay_es5_OverlayRef","OverlayRef","_portalOutlet","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_keydownEvents","attachResult","positionStrategy","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","isAttached","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","updateSize","sizeConfig","setDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","createElement","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","finishDetach_1","setTimeout","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_offsetX","_offsetY","scrollables","_resizeSubscription","EMPTY","_preferredPositions","_applied","_positionLocked","_onPositionChange","_origin","withFallbackPosition","_lastConnectedPosition","recalculateLastPosition","fallbackPoint","fallbackPosition","originRect","viewportSize","_i","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","visibleArea","lastPosition","withScrollableContainers","position","withDirection","withOffsetX","offset","withOffsetY","withLockedPosition","isLocked","withPositions","positions","slice","setOrigin","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","map","s","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","p","positionChange","overflows","arguments","reduce","currentValue","currentOverflow","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","styles","parentStyles","marginLeft","marginTop","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayKeyboardDispatcher","_attachedOverlays","_unsubscribeFromKeydownEvents","_keydownEventSubscription","_subscribeToKeydownEvents","splice","bodyKeydownEvents","_selectOverlayFromEvent","find","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","OverlayContainer","_containerElement","getContainerElement","_createContainer","OVERLAY_CONTAINER_PROVIDER","nextUniqueId","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalOutlet","_createPortalOutlet","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_CdkOverlayOrigin","CdkOverlayOrigin","overlay_es5_CdkConnectedOverlay","CdkConnectedOverlay","_overlay","_scrollStrategy","_hasBackdrop","_lockPosition","_backdropSubscription","open","_templatePortal","_position","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","lockPosition","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","primaryPosition","strategy","i","onPositionChange","keyCode","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","debounceTime","tap","a11y_es5_InteractivityChecker","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","_createAnchor","focusLastTabbableElement","focusFirstTabbableElement","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","querySelectorAll","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","focus","children","childNodes","tabbableChild","nodeType","ELEMENT_NODE","anchor","isStable","a11y_es5_FocusTrapFactory","FocusTrapFactory","deferCaptureElements","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_focusTrapFactory","focusTrap","enabled","disabled","a11y_es5_CdkTrapFocus","CdkTrapFocus","_previouslyFocusedElement","_autoCapture","autoCapture","nextId","messageRegistry","messagesContainer","AriaDescriber","describe","hostElement","message","_canBeDescribed","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_removeMessageReference","registeredMessage","referenceCount","_deleteMessageElement","_deleteMessagesContainer","describedElements","_removeCdkDescribedByReferenceIds","removeAttribute","messageElement","CDK_DESCRIBEDBY_ID_PREFIX","createTextNode","_createMessagesContainer","display","originalReferenceIds","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","_vertical","_skipPredicateFn","_pressedLetters","tabOut","newItems","_activeItem","itemArray","toArray","newIndex","skipPredicate","predicate","withWrap","withVerticalOrientation","withHorizontalOrientation","_horizontal","withTypeAhead","debounceInterval","getLabel","inputString","items","toUpperCase","setActiveItem","previousIndex","onKeydown","setNextItemActive","setPreviousItemActive","toLocaleUpperCase","String","fromCharCode","preventDefault","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","LIVE_ANNOUNCER_ELEMENT_TOKEN","FocusKeyManager","setFocusOrigin","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_windowFocused","_elementInfo","_unregisterGlobalListeners","_monitoredElementCount","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","_setClasses","_decrementMonitoredElementCount","focusVia","_setOriginForCurrentEventQueue","_info","_registerGlobalListeners","documentKeydownListener","_lastTouchTarget","documentMousedownListener","documentTouchstartListener","_touchTimeoutId","clearTimeout","windowFocusListener","_windowFocusTimeoutId","capture","_originTimeoutId","_toggleClass","className","shouldSet","_wasCausedByTouch","focusTarget","Node","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","assign","t","n","hasOwnProperty","ContextMenuContentComponent","changeDetector","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","operators","ContextMenuItemDirective","contextMenu_service___assign","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","concat","attachContextMenu","mouseEvent_1","clientY","clientX","closeAllContextMenus","eventType","contextMenuContent","instance","subscriptions","executeEvent","closeAllEvent","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","closeEvent","getLastAttachedOverlay","_b","newLeaf","subMenuOverlay","isLeafMenu","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","ContextMenuAttachDirective","contextMenuService","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","ngb_date_adapter","datepicker_config","timepicker_config","angular_draggable_droppable","calendar_common_module","calendar_month_module","angular_resizable_element","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","687","isDate","689","observables","isScheduler_1","isScheduler","from_1","from","concatAll_1","concatAll","of_1","690","FromEventObservable_1","FromEventObservable","691","duration","scheduler","async_1","async","audit_1","audit","timer_1","timer","692","durationSelector","source","lift","AuditOperator","__extends","b","__","constructor","tryCatch_1","errorObject_1","OuterSubscriber_1","subscribeToResult_1","subscriber","AuditSubscriber","destination","hasValue","_next","throttled","tryCatch","errorObject","error","innerSubscription","subscribeToResult","closed","clearThrottle","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete","OuterSubscriber","693","dueTime","DebounceTimeOperator","dispatchNext","debouncedNext","Subscriber_1","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","schedule","_complete","Subscriber","694","nextOrObserver","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","_error","err","695","combineLatest","project","pop","isArray_1","ArrayObservable_1","ArrayObservable","CombineLatestOperator","none","CombineLatestSubscriber","active","values","observable","len","toRespond","unused","innerSub","oldVal","_tryProject","result","696","thisArg","TypeError","FindValueOperator","yieldIndex","FindValueSubscriber","697","Subject_1","queue_1","Subscription_1","observeOn_1","ObjectUnsubscribedError_1","SubjectSubscription_1","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_bufferSize","_windowTime","now","_getNow","ReplayEvent","_trimBufferThenGetEvents","_subscribe","ObjectUnsubscribedError","hasError","isStopped","observers","SubjectSubscription","ObserveOnSubscriber","thrownError","queue","eventsCount","spliceCount","time","698","switchMap","resultSelector","SwitchMapOperator","SwitchMapSubscriber","_innerSub","_unsubscribe","_tryNotifyNext","699","zip","zipStatic","ZipOperator","iterator_1","ZipSubscriber","iterators","StaticArrayIterator","iterator","StaticIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","hasCompleted","done","nextResult","array","buffer","isComplete","shift","703","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","toString","isHTMLCollection","isEventTarget","Observable_1","isFunction_1","eventName","isFunction","setupSubscription","handler","source_1","source_2","source_3","704","TimerObservable_1","TimerObservable","705","isNumeric_1","isDate_1","period","isNumeric","initialDelay","dispatch","state","action","706","auditTime_1","buffer_1","bufferCount_1","bufferCount","bufferTime_1","bufferTime","bufferToggle_1","bufferToggle","bufferWhen_1","bufferWhen","catchError_1","catchError","combineAll_1","combineAll","combineLatest_1","concat_1","concatMap_1","concatMap","concatMapTo_1","concatMapTo","count_1","count","debounce_1","debounce","debounceTime_1","defaultIfEmpty_1","defaultIfEmpty","delay_1","delay","delayWhen_1","delayWhen","dematerialize_1","dematerialize","distinct_1","distinct","distinctUntilChanged_1","distinctUntilChanged","distinctUntilKeyChanged_1","distinctUntilKeyChanged","elementAt_1","elementAt","every_1","every","exhaust_1","exhaust","exhaustMap_1","exhaustMap","expand_1","expand","filter_1","finalize_1","finalize","find_1","findIndex_1","findIndex","first_1","first","groupBy_1","groupBy","ignoreElements_1","ignoreElements","isEmpty_1","isEmpty","last_1","last","map_1","mapTo_1","mapTo","materialize_1","materialize","max_1","merge_1","mergeAll_1","mergeAll","mergeMap_1","mergeMap","mergeMap_2","flatMap","mergeMapTo_1","mergeMapTo","mergeScan_1","mergeScan","min_1","min","multicast_1","multicast","observeOn","onErrorResumeNext_1","onErrorResumeNext","pairwise_1","pairwise","partition_1","partition","pluck_1","pluck","publish_1","publish","publishBehavior_1","publishBehavior","publishLast_1","publishLast","publishReplay_1","publishReplay","race_1","race","reduce_1","repeat_1","repeat","repeatWhen_1","repeatWhen","retry_1","retry","retryWhen_1","retryWhen","refCount_1","refCount","sample_1","sample","sampleTime_1","sampleTime","scan_1","scan","sequenceEqual_1","sequenceEqual","share_1","share","shareReplay_1","shareReplay","single_1","single","skip_1","skip","skipLast_1","skipLast","skipUntil_1","skipUntil","skipWhile_1","skipWhile","startWith_1","startWith","switchAll_1","switchAll","switchMap_1","switchMapTo_1","switchMapTo","take_1","takeLast_1","takeLast","takeUntil_1","takeUntil","takeWhile_1","takeWhile","tap_1","throttle_1","throttleTime_1","timeInterval_1","timeInterval","timeout_1","timeout","timeoutWith_1","timeoutWith","timestamp_1","timestamp","toArray_1","window_1","windowCount_1","windowCount","windowTime_1","windowToggle_1","windowToggle","windowWhen_1","windowWhen","withLatestFrom_1","withLatestFrom","zip_1","zipAll_1","zipAll","707","closingNotifier","BufferOperator","BufferSubscriber","708","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","709","bufferTimeSpan","bufferCreationInterval","maxBufferSize","BufferTimeOperator","dispatchBufferTimeSpanOnly","prevContext","closeContext","openContext","closeAction","dispatchBufferCreation","dispatchBufferClose","arg","BufferTimeSubscriber","Context","contexts","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","onBufferFull","710","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","closeBuffer","openBuffer","trySubscribe","711","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","712","713","concat_2","concatStatic","714","innerObservable","715","CountOperator","CountSubscriber","_tryPredicate","716","DebounceOperator","DebounceSubscriber","durationSubscription","_tryNext","emitValue","717","absoluteDelay","delayFor","DelayOperator","Notification_1","DelaySubscriber","errored","notification","observe","_schedule","scheduleNotification","DelayMessage","Notification","createNext","createComplete","718","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","completed","delayNotifierSubscriptions","removeSubscription","tryComplete","notifyError","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","sourceSubscribed","subscribeToSource","719","DeMaterializeOperator","DeMaterializeSubscriber","720","keySelector","flushes","DistinctOperator","Set_1","DistinctSubscriber","Set","_useKeySelector","_finalizeNext","721","minimalSetImpl","MinimalSet","_values","root_1","722","compare","723","defaultValue","ElementAtOperator","ArgumentOutOfRangeError_1","ArgumentOutOfRangeError","ElementAtSubscriber","724","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","725","SwitchFirstMapOperator","SwitchFirstMapSubscriber","tryNext","trySelectResult","726","concurrent","ExpandOperator","ExpandSubscriber","subscribeToProjection","727","callback","FinallyOperator","FinallySubscriber","728","729","elementSelector","subjectSelector","GroupByOperator","Map_1","FastMap_1","GroupBySubscriber","groups","attemptedToUnsubscribe","_group","FastMap","group","groupedObservable","GroupedObservable","GroupDurationSubscriber","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","730","MapPolyfill_1","MapPolyfill","731","size","_keys","cb","732","733","IgnoreElementsOperator","noop_1","IgnoreElementsSubscriber","734","IsEmptyOperator","IsEmptySubscriber","735","MapToOperator","MapToSubscriber","736","MaterializeOperator","MaterializeSubscriber","createError","737","comparer","738","merge_2","mergeStatic","739","MergeMapToOperator","ish","MergeMapToSubscriber","740","accumulator","seed","MergeScanOperator","MergeScanSubscriber","acc","741","742","nextSources","OnErrorResumeNextOperator","onErrorResumeNextStatic","FromObservable_1","FromObservable","OnErrorResumeNextSubscriber","subscribeToNextSource","743","not_1","not","744","pred","notPred","745","properties","plucker","props","currentProp","746","747","BehaviorSubject_1","BehaviorSubject","748","AsyncSubject_1","AsyncSubject","749","hasNext","750","selectorOrScheduler","ReplaySubject_1","751","QueueAction_1","QueueScheduler_1","QueueScheduler","QueueAction","752","AsyncAction_1","work","flush","_execute","requestAsyncId","AsyncAction","753","AsyncScheduler_1","AsyncScheduler","754","755","RaceOperator","RaceSubscriber","hasFirst","756","EmptyObservable_1","EmptyObservable","RepeatOperator","RepeatSubscriber","_unsubscribeAndRecycle","757","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","subscribeToRetries","retriesSubscription","notifications","758","RetryOperator","RetrySubscriber","759","RetryWhenOperator","RetryWhenSubscriber","errors","760","SampleOperator","sampleSubscriber","SampleSubscriber","761","SampleTimeOperator","dispatchNotification","SampleTimeSubscriber","762","compareTo","comparor","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","SequenceEqualCompareToSubscriber","checkValues","_c","a","areEqual","nextB","763","shareReplayOperator","764","SingleOperator","EmptyError_1","SingleSubscriber","seenValue","applySingleValue","singleValue","EmptyError","765","SkipOperator","total","SkipSubscriber","766","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","_ring","skipCount","currentIndex","ring","oldValue","767","SkipUntilOperator","SkipUntilSubscriber","isInnerStopped","768","SkipWhileOperator","SkipWhileSubscriber","skipping","tryCallPredicate","Boolean","769","ScalarObservable_1","ScalarObservable","770","identity_1","identity","771","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","772","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","predicateResult","773","defaultThrottleConfig","ThrottleTimeOperator","leading","trailing","ThrottleTimeSubscriber","_hasTrailingValue","_trailingValue","774","TimeIntervalOperator","TimeInterval","interval","TimeIntervalSubscriber","lastTime","span","775","due","absoluteTimeout","waitFor","TimeoutOperator","TimeoutError_1","TimeoutError","errorInstance","TimeoutSubscriber","scheduleTimeout","dispatchTimeout","776","name","stack","777","withObservable","TimeoutWithOperator","TimeoutWithSubscriber","778","Timestamp","779","toArrayReducer","arr","780","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","newWindow","781","windowSize","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","c","782","windowTimeSpan","windowCreationInterval","maxWindowSize","WindowTimeOperator","dispatchWindowTimeSpanOnly","closeWindow","dispatchWindowCreation","timeSpanState","dispatchWindowClose","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","numberOfNextedValues","window_2","783","WindowToggleOperator","WindowToggleSubscriber","openSubscription","784","unsubscribeClosingNotification","closingNotification","785","WithLatestFromOperator","WithLatestFromSubscriber","found","786"],"mappings":"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","file":"1-7fdf47014c421ba903fa.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 645:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = /** @class */ (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(275);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof Intl !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar platform_es5_Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser && (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) &&\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of `<input>` that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar platform_es5_PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(29);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(11);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(285);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(690);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/auditTime.js\nvar auditTime = __webpack_require__(691);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/filter.js\nvar filter = __webpack_require__(89);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(122);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable[\"Observable\"].create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(Object(auditTime[\"auditTime\"])(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (!_this._scrolledCount) {\n                    _this._removeGlobalListener();\n                }\n            };\n        }) : Object(of[\"of\"])();\n    };\n    /**\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._removeGlobalListener();\n        this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(Object(filter[\"filter\"])(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._removeGlobalListener = /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    function () {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"I\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"I\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject[\"Subject\"]();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: core[\"p\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"I\" /* NgZone */], },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(_platform, ngZone) {\n        var _this = this;\n        this._platform = _platform;\n        this._change = _platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        var /** @type {?} */ output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = /** @type {?} */ ((null));\n        }\n        return output;\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"auditTime\"])(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = this._platform.isBrowser ?\n            { width: window.innerWidth, height: window.innerHeight } :\n            { width: 0, height: 0 };\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"I\" /* NgZone */], },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"I\" /* NgZone */]],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar scrolling_es5_ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_CdkScrollable],\n                    declarations: [scrolling_es5_CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"x\" /* InjectionToken */]('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new core[\"r\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"J\" /* Optional */] }, { type: core[\"v\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar bidi_es5_Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"r\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: core[\"K\" /* Output */], args: ['dirChange',] },],\n        \"dir\": [{ type: core[\"z\" /* Input */] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar bidi_es5_BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: common[\"d\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(44);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n * @template T\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n * @template T\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\nvar portal_es5_ComponentPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n * @template C\n */\nvar portal_es5_TemplatePortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        _this.context = context;\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar portal_es5_DomPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalOutlet, _super);\n    function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this.outletElement = outletElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar portal_es5_CdkPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: core[\"_0\" /* TemplateRef */], },\n        { type: core[\"_5\" /* ViewContainerRef */], },\n    ]; };\n    return CdkPortal;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nvar portal_es5_CdkPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        _this.attached = new core[\"r\" /* EventEmitter */]();\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"attachedRef\", {\n        /** Component or view reference that is attached to the portal. */\n        get: /**\n         * Component or view reference that is attached to the portal.\n         * @return {?}\n         */\n        function () {\n            return this._attachedRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n        this._attachedRef = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_5\" /* ViewContainerRef */], },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: core[\"z\" /* Input */], args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: core[\"z\" /* Input */], args: ['cdkPortalHost',] },],\n        \"attached\": [{ type: core[\"K\" /* Output */], args: ['attached',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar portal_es5_PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    exports: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                    declarations: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/take.js\nvar take = __webpack_require__(123);\nvar take_default = /*#__PURE__*/__webpack_require__.n(take);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(52);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * \\@docs-private\n * @param {?} value\n * @return {?}\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 57;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config)\n                .filter(function (key) { return typeof config[key] !== 'undefined'; })\n                .forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"J\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = this._document.documentElement;\n            var /** @type {?} */ body = this._document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        var /** @type {?} */ html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = this._document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n        this._document = document;\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n        { type: core[\"I\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n        /** The overlay's backdrop HTML element. */\n        get: /**\n         * The overlay's backdrop HTML element.\n         * @return {?}\n         */\n        function () {\n            return this._backdropElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(function () {\n            // The overlay could've been detached before the zone has stabilized.\n            if (_this.hasAttached()) {\n                _this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () {\n                    if (_this._backdropElement) {\n                        _this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n        this._onPositionChange.complete();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.setOrigin = /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin.nativeElement;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        /**\n         * A lazily-created wrapper for the overlay element that is used as a flex container.\n         */\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        var /** @type {?} */ config = this._overlayRef.getConfig();\n        styles.position = this._cssPosition;\n        styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n        styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        parentStyles.justifyContent = config.width === '100%' ? 'flex-start' : this._justifyContent;\n        parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar overlay_es5_OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = Object(fromEvent[\"fromEvent\"])(this._document.body, 'keydown', true);\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(Object(filter[\"filter\"])(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to the correct overlay.\n            // Dispatch keydown event to the correct overlay.\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use the overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new overlay_es5_OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_es5_OverlayKeyboardDispatcher,\n    deps: [\n        [new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), overlay_es5_OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar overlay_es5_OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new overlay_es5_OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [\n        [new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), overlay_es5_OverlayContainer],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */] // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new overlay_es5_OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new portal_es5_DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: overlay_es5_OverlayKeyboardDispatcher, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"y\" /* Injector */], },\n        { type: core[\"I\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"x\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"p\" /* ElementRef */], },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._lockPosition = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"r\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"r\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"r\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"r\" /* EventEmitter */]();\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"lockPosition\", {\n        get: /**\n         * Whether or not the overlay should be locked when scrolling.\n         * @return {?}\n         */\n        function () { return this._lockPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._lockPosition = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (this._position) {\n            if (changes['positions'] || changes['_deprecatedPositions']) {\n                this._position.withPositions(this.positions);\n            }\n            if (changes['lockPosition']) {\n                this._position.withLockedPosition(this.lockPosition);\n            }\n            if (changes['origin'] || changes['_deprecatedOrigin']) {\n                this._position.setOrigin(this.origin.elementRef);\n                if (this.open) {\n                    this._position.apply();\n                }\n            }\n        }\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ primaryPosition = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: primaryPosition.originX, originY: primaryPosition.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: primaryPosition.overlayX, overlayY: primaryPosition.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY)\n            .withLockedPosition(this.lockPosition);\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n        return strategy;\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {\n                _this.backdropClick.emit(event);\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"_0\" /* TemplateRef */], },\n        { type: core[\"_5\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"J\" /* Optional */] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"lockPosition\": [{ type: core[\"z\" /* Input */], args: ['cdkConnectedOverlayLockPosition',] },],\n        \"_deprecatedOrigin\": [{ type: core[\"z\" /* Input */], args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: core[\"z\" /* Input */], args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: core[\"z\" /* Input */], args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: core[\"z\" /* Input */], args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: core[\"z\" /* Input */], args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: core[\"z\" /* Input */], args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: core[\"z\" /* Input */], args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: core[\"z\" /* Input */], args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: core[\"z\" /* Input */], args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: core[\"z\" /* Input */], args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: core[\"z\" /* Input */], args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: core[\"z\" /* Input */], args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: core[\"K\" /* Output */] },],\n        \"positionChange\": [{ type: core[\"K\" /* Output */] },],\n        \"attach\": [{ type: core[\"K\" /* Output */] },],\n        \"detach\": [{ type: core[\"K\" /* Output */] },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    imports: [bidi_es5_BidiModule, portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar overlay_es5_FullscreenOverlayContainer = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"x\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/debounceTime.js\nvar debounceTime = __webpack_require__(693);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/map.js\nvar map = __webpack_require__(88);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/tap.js\nvar tap = __webpack_require__(694);\nvar tap_default = /*#__PURE__*/__webpack_require__.n(tap);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch (/** @type {?} */ e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar a11y_es5_FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new a11y_es5_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: core[\"I\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n * \\@deletion-target 6.0.0\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"p\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: core[\"z\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: core[\"p\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: core[\"z\" /* Input */], args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: core[\"z\" /* Input */], args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._canBeDescribed = /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        return element.nodeType === this._document.ELEMENT_NODE && message != null &&\n            !!(\"\" + message).trim();\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nvar a11y_es5_ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._vertical = true;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = function (item) { return item.disabled; };\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject[\"Subject\"]();\n        _items.changes.subscribe(function (newItems) {\n            if (_this._activeItem) {\n                var /** @type {?} */ itemArray = newItems.toArray();\n                var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                    _this._activeItemIndex = newIndex;\n                }\n            }\n        });\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    ListKeyManager.prototype.skipPredicate = /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    function (predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    };\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        this._vertical = enabled;\n        return this;\n    };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    function (direction) {\n        this._horizontal = direction;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"tap\"])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(debounceTime[\"debounceTime\"])(debounceInterval), Object(filter[\"filter\"])(function () { return _this._pressedLetters.length > 0; }), Object(map[\"map\"])(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        for (var /** @type {?} */ i = 1; i <= items.length; i++) {\n            var /** @type {?} */ index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            var /** @type {?} */ item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\n/**\n * @template T\n */\nvar a11y_es5_ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\n/**\n * @template T\n */\nvar a11y_es5_FocusKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin;\n        return this;\n    };\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"x\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                _this._liveElement.textContent = message;\n                resolve();\n            }, 100);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"J\" /* Optional */] }, { type: core[\"v\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: core[\"v\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"J\" /* Optional */](), new core[\"v\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        common[\"d\" /* DOCUMENT */],\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof core[\"R\" /* Renderer2 */])) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeoutId != null) {\n                clearTimeout(_this._touchTimeoutId);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(_this._windowFocusTimeoutId);\n            clearTimeout(_this._touchTimeoutId);\n            clearTimeout(_this._originTimeoutId);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"I\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"r\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"p\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: core[\"K\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"J\" /* Optional */](), new core[\"X\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"I\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar a11y_es5_A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"r\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"r\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"r\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"r\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"O\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE, event: event });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit({ event: event });\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" [ngClass]=\\\"menuClass\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"p\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"J\" /* Optional */] }, { type: core[\"v\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"Q\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: core[\"z\" /* Input */] },],\n        \"item\": [{ type: core[\"z\" /* Input */] },],\n        \"event\": [{ type: core[\"z\" /* Input */] },],\n        \"parentContextMenu\": [{ type: core[\"z\" /* Input */] },],\n        \"menuClass\": [{ type: core[\"z\" /* Input */] },],\n        \"overlay\": [{ type: core[\"z\" /* Input */] },],\n        \"isLeaf\": [{ type: core[\"z\" /* Input */] },],\n        \"execute\": [{ type: core[\"K\" /* Output */] },],\n        \"openSubMenu\": [{ type: core[\"K\" /* Output */] },],\n        \"closeLeafMenu\": [{ type: core[\"K\" /* Output */] },],\n        \"closeAllMenus\": [{ type: core[\"K\" /* Output */] },],\n        \"menuElement\": [{ type: core[\"_3\" /* ViewChild */], args: ['menu',] },],\n        \"menuItemElements\": [{ type: core[\"_4\" /* ViewChildren */], args: ['li',] },],\n        \"onKeyEvent\": [{ type: core[\"u\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"u\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: core[\"u\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: core[\"u\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"u\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: core[\"u\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"u\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: core[\"u\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"u\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_20\" /* crt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_17\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_21\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_5\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_38\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_17\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_21\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_5\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_38\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_21\" /* did */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_21\" /* did */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_46\" /* vid */](0, [core[\"_42\" /* qud */](402653184, 1, { menuElement: 0 }), core[\"_42\" /* qud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_22\" /* eld */](2, 0, null, null, 8, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), core[\"_21\" /* did */](3, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"A\" /* IterableDiffers */], core[\"B\" /* KeyValueDiffers */], core[\"p\" /* ElementRef */], core[\"R\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_22\" /* eld */](5, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_21\" /* did */](8, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], core[\"A\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = \"dropdown open show ngx-contextmenu\"; var currVal_1 = _co.menuClass; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.menuItems; _ck(_v, 8, 0, currVal_2); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_34\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_34\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_34\" /* nov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_34\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_34\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_34\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_34\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_34\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_34\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_21\" /* did */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"p\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"Q\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_18\" /* ccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", menuClass: \"menuClass\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(276);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(91);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators.js\nvar operators = __webpack_require__(706);\nvar operators_default = /*#__PURE__*/__webpack_require__.n(operators);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"r\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_0\" /* TemplateRef */], },\n        { type: core[\"p\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: core[\"z\" /* Input */] },],\n        \"divider\": [{ type: core[\"z\" /* Input */] },],\n        \"enabled\": [{ type: core[\"z\" /* Input */] },],\n        \"passive\": [{ type: core[\"z\" /* Input */] },],\n        \"visible\": [{ type: core[\"z\" /* Input */] },],\n        \"execute\": [{ type: core[\"K\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\nvar contextMenu_service___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            var mouseEvent_1 = event;\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: mouseEvent_1.clientY,\n                    height: 0,\n                    left: mouseEvent_1.clientX,\n                    right: mouseEvent_1.clientX,\n                    top: mouseEvent_1.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus({ eventType: 'cancel', event: event });\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems, menuClass = context.menuClass;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        contextMenuContent.instance.menuClass = menuClass;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function (executeEvent) { return _this.closeAllContextMenus(contextMenu_service___assign({ eventType: 'execute' }, executeEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function (closeAllEvent) { return _this.closeAllContextMenus(contextMenu_service___assign({ eventType: 'cancel' }, closeAllEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function (closeEvent) {\n        if (this.overlays) {\n            this.close.next(closeEvent);\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > 1 && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {\n                _this.close.next({ eventType: 'cancel', event: event });\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"w\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.menuClass = \"\";\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"r\" /* EventEmitter */]();\n        this.open = new core[\"r\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) {\n            _this.onMenuEvent(menuEvent);\n        }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        var _this = this;\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));\n        this._contextMenuService.close.asObservable().pipe(Object(operators[\"first\"])()).subscribe(function (closeEvent) { return _this.close.emit(closeEvent); });\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_6\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"p\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"J\" /* Optional */] }, { type: core[\"v\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"menuClass\": [{ type: core[\"z\" /* Input */] },],\n        \"autoFocus\": [{ type: core[\"z\" /* Input */] },],\n        \"useBootstrap4\": [{ type: core[\"z\" /* Input */] },],\n        \"disabled\": [{ type: core[\"z\" /* Input */] },],\n        \"close\": [{ type: core[\"K\" /* Output */] },],\n        \"open\": [{ type: core[\"K\" /* Output */] },],\n        \"menuItems\": [{ type: core[\"n\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: core[\"_3\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"o\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: core[\"z\" /* Input */] },],\n        \"contextMenu\": [{ type: core[\"z\" /* Input */] },],\n        \"onContextMenu\": [{ type: core[\"u\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(280);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(84);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(282);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(86);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(281);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(85);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(62);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(34);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(92);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(684);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(683);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_20\" /* crt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_46\" /* vid */](0, [core[\"_42\" /* qud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_44\" /* ted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_21\" /* did */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"p\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_42\" /* qud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_18\" /* ccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { menuClass: \"menuClass\", autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(685);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\nvar component_DemoComponent = /** @class */ (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_20\" /* crt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_34\" /* nov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_34\" /* nov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_21\" /* did */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"A\" /* IterableDiffers */], core[\"B\" /* KeyValueDiffers */], core[\"p\" /* ElementRef */], core[\"R\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_21\" /* did */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"p\" /* ElementRef */], core[\"y\" /* Injector */], core[\"R\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_5\" /* ViewContainerRef */], common[\"d\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_39\" /* ppd */](3, 3), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_17\" /* and */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_45\" /* unv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_34\" /* nov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_22\" /* eld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_34\" /* nov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_21\" /* did */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_22\" /* eld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_21\" /* did */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_22\" /* eld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](10, null, [\"\", \"\"])), core[\"_39\" /* ppd */](11, 3), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_22\" /* eld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_21\" /* did */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], core[\"A\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_34\" /* nov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_45\" /* unv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_34\" /* nov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_34\" /* nov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_21\" /* did */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_22\" /* eld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](4, null, [\"\", \"\"])), core[\"_39\" /* ppd */](5, 3), (_l()(), core[\"_22\" /* eld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_22\" /* eld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](9, null, [\"\", \"\"])), core[\"_39\" /* ppd */](10, 3), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_34\" /* nov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_45\" /* unv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_34\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_45\" /* unv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_34\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_22\" /* eld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_21\" /* did */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], core[\"A\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_22\" /* eld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_34\" /* nov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_21\" /* did */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"A\" /* IterableDiffers */], core[\"B\" /* KeyValueDiffers */], core[\"p\" /* ElementRef */], core[\"R\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_21\" /* did */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_22\" /* eld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_44\" /* ted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_39\" /* ppd */](7, 3), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_34\" /* nov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_45\" /* unv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_34\" /* nov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_21\" /* did */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"C\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_34\" /* nov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_21\" /* did */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"C\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_34\" /* nov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_21\" /* did */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"C\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_34\" /* nov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_46\" /* vid */](2, [core[\"_37\" /* pid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"C\" /* LOCALE_ID */]]), core[\"_37\" /* pid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_22\" /* eld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_21\" /* did */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_22\" /* eld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_21\" /* did */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"p\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_42\" /* qud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_17\" /* and */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_21\" /* did */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_0\" /* TemplateRef */], core[\"p\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_17\" /* and */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_17\" /* and */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_17\" /* and */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_22\" /* eld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_21\" /* did */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_21\" /* did */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_21\" /* did */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_17\" /* and */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_21\" /* did */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_5\" /* ViewContainerRef */], core[\"_0\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_44\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_46\" /* vid */](0, [(_l()(), core[\"_22\" /* eld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_21\" /* did */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_18\" /* ccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(17);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(59);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter.js\nvar ngb_date_adapter = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(58);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(51);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/esm5/angular-draggable-droppable.js\nvar angular_draggable_droppable = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(118);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(166);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/esm5/angular-resizable-element.js\nvar angular_resizable_element = __webpack_require__(117);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(167);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(168);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(274);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                contextMenu_service_ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"D\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 3 modules\nvar datepicker_module = __webpack_require__(277);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(278);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(279);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(119);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_19\" /* cmf */](DemoModule, [], function (_l) { return core[\"_30\" /* mod */]([core[\"_31\" /* mpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_15\" /* CodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"G\" /* NgModuleRef */]]), core[\"_31\" /* mpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"C\" /* LOCALE_ID */], [2, common[\"y\" /* a */]]]), core[\"_31\" /* mpd */](6144, DIR_DOCUMENT, null, [common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](4608, bidi_es5_Directionality, bidi_es5_Directionality, [[2, DIR_DOCUMENT]]), core[\"_31\" /* mpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_31\" /* mpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"I\" /* NgZone */], platform_es5_Platform]), core[\"_31\" /* mpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"I\" /* NgZone */]]), core[\"_31\" /* mpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler, core[\"I\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer], common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler, common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](5120, overlay_es5_OverlayKeyboardDispatcher, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayKeyboardDispatcher], common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayKeyboardDispatcher, core[\"g\" /* ApplicationRef */], core[\"y\" /* Injector */], core[\"I\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_31\" /* mpd */](5120, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_31\" /* mpd */](4608, esm5_forms[\"o\" /* i */], esm5_forms[\"o\" /* i */], []), core[\"_31\" /* mpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_31\" /* mpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_31\" /* mpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_31\" /* mpd */](4608, ngb_date_adapter[\"a\" /* NgbDateAdapter */], ngb_date_adapter[\"b\" /* NgbDateStructAdapter */], []), core[\"_31\" /* mpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_31\" /* mpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_31\" /* mpd */](4608, angular_draggable_droppable[\"b\" /* DraggableHelper */], angular_draggable_droppable[\"b\" /* DraggableHelper */], []), core[\"_31\" /* mpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_31\" /* mpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_31\" /* mpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_31\" /* mpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_31\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_31\" /* mpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_31\" /* mpd */](512, angular_draggable_droppable[\"a\" /* DragAndDropModule */], angular_draggable_droppable[\"a\" /* DragAndDropModule */], []), core[\"_31\" /* mpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_31\" /* mpd */](512, angular_resizable_element[\"b\" /* ResizableModule */], angular_resizable_element[\"b\" /* ResizableModule */], []), core[\"_31\" /* mpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_31\" /* mpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_31\" /* mpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_31\" /* mpd */](512, bidi_es5_BidiModule, bidi_es5_BidiModule, []), core[\"_31\" /* mpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_31\" /* mpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_31\" /* mpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_31\" /* mpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_31\" /* mpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_31\" /* mpd */](512, esm5_forms[\"m\" /* ba */], esm5_forms[\"m\" /* ba */], []), core[\"_31\" /* mpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_31\" /* mpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_31\" /* mpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_31\" /* mpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_31\" /* mpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* a */]], [2, router[\"m\" /* Router */]]]), core[\"_31\" /* mpd */](512, DemoModule, DemoModule, []), core[\"_31\" /* mpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_31\" /* mpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 687:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 689:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(171);\nvar of_1 = __webpack_require__(285);\nvar from_1 = __webpack_require__(305);\nvar concatAll_1 = __webpack_require__(296);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 690:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(703);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 691:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(283);\nvar audit_1 = __webpack_require__(692);\nvar timer_1 = __webpack_require__(704);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 692:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 693:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(283);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 694:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ }),\n\n/***/ 695:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(121);\nvar isArray_1 = __webpack_require__(87);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n\n/***/ 696:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n\n/***/ 697:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar queue_1 = __webpack_require__(751);\nvar Subscription_1 = __webpack_require__(52);\nvar observeOn_1 = __webpack_require__(294);\nvar ObjectUnsubscribedError_1 = __webpack_require__(176);\nvar SubjectSubscription_1 = __webpack_require__(300);\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    /** @deprecated internal use only */ ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n/***/ }),\n\n/***/ 698:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    /** @deprecated internal use only */ SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n\n/***/ 699:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(121);\nvar isArray_1 = __webpack_require__(87);\nvar Subscriber_1 = __webpack_require__(10);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\nvar iterator_1 = __webpack_require__(126);\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n\n/***/ 703:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(11);\nvar tryCatch_1 = __webpack_require__(169);\nvar isFunction_1 = __webpack_require__(174);\nvar errorObject_1 = __webpack_require__(120);\nvar Subscription_1 = __webpack_require__(52);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    /** @deprecated internal use only */ FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }),\n\n/***/ 704:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(705);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 705:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(288);\nvar Observable_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(283);\nvar isScheduler_1 = __webpack_require__(171);\nvar isDate_1 = __webpack_require__(687);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    /** @deprecated internal use only */ TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 706:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar audit_1 = __webpack_require__(692);\nexports.audit = audit_1.audit;\nvar auditTime_1 = __webpack_require__(691);\nexports.auditTime = auditTime_1.auditTime;\nvar buffer_1 = __webpack_require__(707);\nexports.buffer = buffer_1.buffer;\nvar bufferCount_1 = __webpack_require__(708);\nexports.bufferCount = bufferCount_1.bufferCount;\nvar bufferTime_1 = __webpack_require__(709);\nexports.bufferTime = bufferTime_1.bufferTime;\nvar bufferToggle_1 = __webpack_require__(710);\nexports.bufferToggle = bufferToggle_1.bufferToggle;\nvar bufferWhen_1 = __webpack_require__(711);\nexports.bufferWhen = bufferWhen_1.bufferWhen;\nvar catchError_1 = __webpack_require__(307);\nexports.catchError = catchError_1.catchError;\nvar combineAll_1 = __webpack_require__(712);\nexports.combineAll = combineAll_1.combineAll;\nvar combineLatest_1 = __webpack_require__(695);\nexports.combineLatest = combineLatest_1.combineLatest;\nvar concat_1 = __webpack_require__(713);\nexports.concat = concat_1.concat;\nvar concatAll_1 = __webpack_require__(296);\nexports.concatAll = concatAll_1.concatAll;\nvar concatMap_1 = __webpack_require__(293);\nexports.concatMap = concatMap_1.concatMap;\nvar concatMapTo_1 = __webpack_require__(714);\nexports.concatMapTo = concatMapTo_1.concatMapTo;\nvar count_1 = __webpack_require__(715);\nexports.count = count_1.count;\nvar debounce_1 = __webpack_require__(716);\nexports.debounce = debounce_1.debounce;\nvar debounceTime_1 = __webpack_require__(693);\nexports.debounceTime = debounceTime_1.debounceTime;\nvar defaultIfEmpty_1 = __webpack_require__(312);\nexports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\nvar delay_1 = __webpack_require__(717);\nexports.delay = delay_1.delay;\nvar delayWhen_1 = __webpack_require__(718);\nexports.delayWhen = delayWhen_1.delayWhen;\nvar dematerialize_1 = __webpack_require__(719);\nexports.dematerialize = dematerialize_1.dematerialize;\nvar distinct_1 = __webpack_require__(720);\nexports.distinct = distinct_1.distinct;\nvar distinctUntilChanged_1 = __webpack_require__(287);\nexports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\nvar distinctUntilKeyChanged_1 = __webpack_require__(722);\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\nvar elementAt_1 = __webpack_require__(723);\nexports.elementAt = elementAt_1.elementAt;\nvar every_1 = __webpack_require__(309);\nexports.every = every_1.every;\nvar exhaust_1 = __webpack_require__(724);\nexports.exhaust = exhaust_1.exhaust;\nvar exhaustMap_1 = __webpack_require__(725);\nexports.exhaustMap = exhaustMap_1.exhaustMap;\nvar expand_1 = __webpack_require__(726);\nexports.expand = expand_1.expand;\nvar filter_1 = __webpack_require__(89);\nexports.filter = filter_1.filter;\nvar finalize_1 = __webpack_require__(727);\nexports.finalize = finalize_1.finalize;\nvar find_1 = __webpack_require__(696);\nexports.find = find_1.find;\nvar findIndex_1 = __webpack_require__(728);\nexports.findIndex = findIndex_1.findIndex;\nvar first_1 = __webpack_require__(308);\nexports.first = first_1.first;\nvar groupBy_1 = __webpack_require__(729);\nexports.groupBy = groupBy_1.groupBy;\nvar ignoreElements_1 = __webpack_require__(733);\nexports.ignoreElements = ignoreElements_1.ignoreElements;\nvar isEmpty_1 = __webpack_require__(734);\nexports.isEmpty = isEmpty_1.isEmpty;\nvar last_1 = __webpack_require__(310);\nexports.last = last_1.last;\nvar map_1 = __webpack_require__(88);\nexports.map = map_1.map;\nvar mapTo_1 = __webpack_require__(735);\nexports.mapTo = mapTo_1.mapTo;\nvar materialize_1 = __webpack_require__(736);\nexports.materialize = materialize_1.materialize;\nvar max_1 = __webpack_require__(737);\nexports.max = max_1.max;\nvar merge_1 = __webpack_require__(738);\nexports.merge = merge_1.merge;\nvar mergeAll_1 = __webpack_require__(125);\nexports.mergeAll = mergeAll_1.mergeAll;\nvar mergeMap_1 = __webpack_require__(64);\nexports.mergeMap = mergeMap_1.mergeMap;\nvar mergeMap_2 = __webpack_require__(64);\nexports.flatMap = mergeMap_2.mergeMap;\nvar mergeMapTo_1 = __webpack_require__(739);\nexports.mergeMapTo = mergeMapTo_1.mergeMapTo;\nvar mergeScan_1 = __webpack_require__(740);\nexports.mergeScan = mergeScan_1.mergeScan;\nvar min_1 = __webpack_require__(741);\nexports.min = min_1.min;\nvar multicast_1 = __webpack_require__(284);\nexports.multicast = multicast_1.multicast;\nvar observeOn_1 = __webpack_require__(294);\nexports.observeOn = observeOn_1.observeOn;\nvar onErrorResumeNext_1 = __webpack_require__(742);\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\nvar pairwise_1 = __webpack_require__(182);\nexports.pairwise = pairwise_1.pairwise;\nvar partition_1 = __webpack_require__(743);\nexports.partition = partition_1.partition;\nvar pluck_1 = __webpack_require__(745);\nexports.pluck = pluck_1.pluck;\nvar publish_1 = __webpack_require__(746);\nexports.publish = publish_1.publish;\nvar publishBehavior_1 = __webpack_require__(747);\nexports.publishBehavior = publishBehavior_1.publishBehavior;\nvar publishLast_1 = __webpack_require__(748);\nexports.publishLast = publishLast_1.publishLast;\nvar publishReplay_1 = __webpack_require__(750);\nexports.publishReplay = publishReplay_1.publishReplay;\nvar race_1 = __webpack_require__(754);\nexports.race = race_1.race;\nvar reduce_1 = __webpack_require__(286);\nexports.reduce = reduce_1.reduce;\nvar repeat_1 = __webpack_require__(756);\nexports.repeat = repeat_1.repeat;\nvar repeatWhen_1 = __webpack_require__(757);\nexports.repeatWhen = repeatWhen_1.repeatWhen;\nvar retry_1 = __webpack_require__(758);\nexports.retry = retry_1.retry;\nvar retryWhen_1 = __webpack_require__(759);\nexports.retryWhen = retryWhen_1.retryWhen;\nvar refCount_1 = __webpack_require__(177);\nexports.refCount = refCount_1.refCount;\nvar sample_1 = __webpack_require__(760);\nexports.sample = sample_1.sample;\nvar sampleTime_1 = __webpack_require__(761);\nexports.sampleTime = sampleTime_1.sampleTime;\nvar scan_1 = __webpack_require__(311);\nexports.scan = scan_1.scan;\nvar sequenceEqual_1 = __webpack_require__(762);\nexports.sequenceEqual = sequenceEqual_1.sequenceEqual;\nvar share_1 = __webpack_require__(127);\nexports.share = share_1.share;\nvar shareReplay_1 = __webpack_require__(763);\nexports.shareReplay = shareReplay_1.shareReplay;\nvar single_1 = __webpack_require__(764);\nexports.single = single_1.single;\nvar skip_1 = __webpack_require__(765);\nexports.skip = skip_1.skip;\nvar skipLast_1 = __webpack_require__(766);\nexports.skipLast = skipLast_1.skipLast;\nvar skipUntil_1 = __webpack_require__(767);\nexports.skipUntil = skipUntil_1.skipUntil;\nvar skipWhile_1 = __webpack_require__(768);\nexports.skipWhile = skipWhile_1.skipWhile;\nvar startWith_1 = __webpack_require__(769);\nexports.startWith = startWith_1.startWith;\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\nvar switchAll_1 = __webpack_require__(770);\nexports.switchAll = switchAll_1.switchAll;\nvar switchMap_1 = __webpack_require__(698);\nexports.switchMap = switchMap_1.switchMap;\nvar switchMapTo_1 = __webpack_require__(771);\nexports.switchMapTo = switchMapTo_1.switchMapTo;\nvar take_1 = __webpack_require__(123);\nexports.take = take_1.take;\nvar takeLast_1 = __webpack_require__(181);\nexports.takeLast = takeLast_1.takeLast;\nvar takeUntil_1 = __webpack_require__(180);\nexports.takeUntil = takeUntil_1.takeUntil;\nvar takeWhile_1 = __webpack_require__(772);\nexports.takeWhile = takeWhile_1.takeWhile;\nvar tap_1 = __webpack_require__(694);\nexports.tap = tap_1.tap;\nvar throttle_1 = __webpack_require__(289);\nexports.throttle = throttle_1.throttle;\nvar throttleTime_1 = __webpack_require__(773);\nexports.throttleTime = throttleTime_1.throttleTime;\nvar timeInterval_1 = __webpack_require__(774);\nexports.timeInterval = timeInterval_1.timeInterval;\nvar timeout_1 = __webpack_require__(775);\nexports.timeout = timeout_1.timeout;\nvar timeoutWith_1 = __webpack_require__(777);\nexports.timeoutWith = timeoutWith_1.timeoutWith;\nvar timestamp_1 = __webpack_require__(778);\nexports.timestamp = timestamp_1.timestamp;\nvar toArray_1 = __webpack_require__(779);\nexports.toArray = toArray_1.toArray;\nvar window_1 = __webpack_require__(780);\nexports.window = window_1.window;\nvar windowCount_1 = __webpack_require__(781);\nexports.windowCount = windowCount_1.windowCount;\nvar windowTime_1 = __webpack_require__(782);\nexports.windowTime = windowTime_1.windowTime;\nvar windowToggle_1 = __webpack_require__(783);\nexports.windowToggle = windowToggle_1.windowToggle;\nvar windowWhen_1 = __webpack_require__(784);\nexports.windowWhen = windowWhen_1.windowWhen;\nvar withLatestFrom_1 = __webpack_require__(785);\nexports.withLatestFrom = withLatestFrom_1.withLatestFrom;\nvar zip_1 = __webpack_require__(699);\nexports.zip = zip_1.zip;\nvar zipAll_1 = __webpack_require__(786);\nexports.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=operators.js.map\n\n/***/ }),\n\n/***/ 707:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n/***/ }),\n\n/***/ 708:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ 709:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(283);\nvar Subscriber_1 = __webpack_require__(10);\nvar isScheduler_1 = __webpack_require__(171);\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n/***/ }),\n\n/***/ 710:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(52);\nvar subscribeToResult_1 = __webpack_require__(60);\nvar OuterSubscriber_1 = __webpack_require__(61);\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n/***/ }),\n\n/***/ 711:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(52);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n/***/ }),\n\n/***/ 712:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar combineLatest_1 = __webpack_require__(695);\nfunction combineAll(project) {\n    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/***/ }),\n\n/***/ 713:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(689);\nvar concat_2 = __webpack_require__(689);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concatMap_1 = __webpack_require__(293);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/***/ }),\n\n/***/ 715:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return function (source) { return source.lift(new CountOperator(predicate, source)); };\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n/***/ }),\n\n/***/ 716:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n\n/***/ 717:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(283);\nvar isDate_1 = __webpack_require__(687);\nvar Subscriber_1 = __webpack_require__(10);\nvar Notification_1 = __webpack_require__(295);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar Observable_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\n                .lift(new DelayWhenOperator(delayDurationSelector));\n        };\n    }\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(/** @deprecated internal use only */ source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    /** @deprecated internal use only */ SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n/***/ }),\n\n/***/ 719:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n/***/ }),\n\n/***/ 720:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\nvar Set_1 = __webpack_require__(721);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n/***/ }),\n\n/***/ 721:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(36);\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n/***/ }),\n\n/***/ 722:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar distinctUntilChanged_1 = __webpack_require__(287);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/***/ }),\n\n/***/ 723:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(172);\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n/***/ }),\n\n/***/ 724:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return function (source) { return source.lift(new SwitchFirstOperator()); };\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n/***/ }),\n\n/***/ 725:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n/***/ }),\n\n/***/ 726:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n/***/ }),\n\n/***/ 727:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar Subscription_1 = __webpack_require__(52);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n/***/ }),\n\n/***/ 728:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar find_1 = __webpack_require__(696);\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/***/ }),\n\n/***/ 729:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar Subscription_1 = __webpack_require__(52);\nvar Observable_1 = __webpack_require__(11);\nvar Subject_1 = __webpack_require__(29);\nvar Map_1 = __webpack_require__(730);\nvar FastMap_1 = __webpack_require__(732);\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    /** @deprecated internal use only */ GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    /** @deprecated internal use only */ GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n/***/ }),\n\n/***/ 730:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(36);\nvar MapPolyfill_1 = __webpack_require__(731);\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n/***/ }),\n\n/***/ 731:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n/***/ }),\n\n/***/ 732:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n/***/ }),\n\n/***/ 733:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar noop_1 = __webpack_require__(298);\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nexports.ignoreElements = ignoreElements;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n/***/ }),\n\n/***/ 734:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nfunction isEmpty() {\n    return function (source) { return source.lift(new IsEmptyOperator()); };\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n/***/ }),\n\n/***/ 735:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n/***/ }),\n\n/***/ 736:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar Notification_1 = __webpack_require__(295);\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n/***/ }),\n\n/***/ 737:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(286);\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return reduce_1.reduce(max);\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n/***/ }),\n\n/***/ 738:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(122);\nvar merge_2 = __webpack_require__(122);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 739:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/***/ }),\n\n/***/ 740:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar subscribeToResult_1 = __webpack_require__(60);\nvar OuterSubscriber_1 = __webpack_require__(61);\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n/***/ }),\n\n/***/ 741:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(286);\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return reduce_1.reduce(min);\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n/***/ }),\n\n/***/ 742:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = __webpack_require__(306);\nvar isArray_1 = __webpack_require__(87);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n\n/***/ 743:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar not_1 = __webpack_require__(744);\nvar filter_1 = __webpack_require__(89);\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return function (source) { return [\n        filter_1.filter(predicate, thisArg)(source),\n        filter_1.filter(not_1.not(predicate, thisArg))(source)\n    ]; };\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n/***/ }),\n\n/***/ 744:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n/***/ }),\n\n/***/ 745:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar map_1 = __webpack_require__(88);\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return map_1.map(plucker(properties, length))(source); };\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n/***/ }),\n\n/***/ 746:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Subject_1 = __webpack_require__(29);\nvar multicast_1 = __webpack_require__(284);\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n/***/ }),\n\n/***/ 747:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar BehaviorSubject_1 = __webpack_require__(304);\nvar multicast_1 = __webpack_require__(284);\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/***/ }),\n\n/***/ 748:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncSubject_1 = __webpack_require__(749);\nvar multicast_1 = __webpack_require__(284);\nfunction publishLast() {\n    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/***/ }),\n\n/***/ 749:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar Subscription_1 = __webpack_require__(52);\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    /** @deprecated internal use only */ AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n/***/ }),\n\n/***/ 750:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ReplaySubject_1 = __webpack_require__(697);\nvar multicast_1 = __webpack_require__(284);\n/* tslint:enable:max-line-length */\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/***/ }),\n\n/***/ 751:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar QueueAction_1 = __webpack_require__(752);\nvar QueueScheduler_1 = __webpack_require__(753);\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n/***/ }),\n\n/***/ 752:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(301);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n/***/ }),\n\n/***/ 753:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(302);\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n/***/ }),\n\n/***/ 754:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(87);\nvar race_1 = __webpack_require__(755);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        // if the only argument is an array, it was most likely called with\n        // `pair([obs1, obs2, ...])`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.race = race;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ 755:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(87);\nvar ArrayObservable_1 = __webpack_require__(121);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.race = race;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ 756:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar EmptyObservable_1 = __webpack_require__(63);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ 757:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            if (!this.retriesSubscription || this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) { return source.lift(new RetryOperator(count, source)); };\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n/***/ }),\n\n/***/ 759:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    /** @deprecated internal use only */ RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n/***/ }),\n\n/***/ 760:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n/***/ }),\n\n/***/ 761:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(283);\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n/***/ }),\n\n/***/ 762:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n/***/ }),\n\n/***/ 763:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ReplaySubject_1 = __webpack_require__(697);\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n}\nexports.shareReplay = shareReplay;\nfunction shareReplayOperator(bufferSize, windowTime, scheduler) {\n    var subject;\n    var refCount = 0;\n    var subscription;\n    var hasError = false;\n    var isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next: function (value) { subject.next(value); },\n                error: function (err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete: function () {\n                    isComplete = true;\n                    subject.complete();\n                },\n            });\n        }\n        var innerSub = subject.subscribe(this);\n        return function () {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && refCount === 0 && isComplete) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n}\n;\n//# sourceMappingURL=shareReplay.js.map\n\n/***/ }),\n\n/***/ 764:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar EmptyError_1 = __webpack_require__(129);\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n/***/ }),\n\n/***/ 765:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n/***/ }),\n\n/***/ 766:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(172);\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n/***/ }),\n\n/***/ 767:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n/***/ }),\n\n/***/ 768:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n/***/ }),\n\n/***/ 769:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(121);\nvar ScalarObservable_1 = __webpack_require__(175);\nvar EmptyObservable_1 = __webpack_require__(63);\nvar concat_1 = __webpack_require__(689);\nvar isScheduler_1 = __webpack_require__(171);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n\n/***/ 770:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar switchMap_1 = __webpack_require__(698);\nvar identity_1 = __webpack_require__(299);\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n/***/ }),\n\n/***/ 771:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    /** @deprecated internal use only */ SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n/***/ }),\n\n/***/ 772:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n/***/ }),\n\n/***/ 773:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(283);\nvar throttle_1 = __webpack_require__(289);\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n/***/ }),\n\n/***/ 774:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(283);\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n/***/ }),\n\n/***/ 775:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(283);\nvar isDate_1 = __webpack_require__(687);\nvar Subscriber_1 = __webpack_require__(10);\nvar TimeoutError_1 = __webpack_require__(776);\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n/***/ }),\n\n/***/ 776:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n/***/ }),\n\n/***/ 777:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(283);\nvar isDate_1 = __webpack_require__(687);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) {\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n/***/ }),\n\n/***/ 778:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(283);\nvar map_1 = __webpack_require__(88);\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\n//# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n\n/***/ 779:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(286);\nfunction toArrayReducer(arr, item, index) {\n    if (index === 0) {\n        return [item];\n    }\n    arr.push(item);\n    return arr;\n}\nfunction toArray() {\n    return reduce_1.reduce(toArrayReducer, []);\n}\nexports.toArray = toArray;\n//# sourceMappingURL=toArray.js.map\n\n/***/ }),\n\n/***/ 780:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    /** @deprecated internal use only */ WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n/***/ }),\n\n/***/ 781:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar Subject_1 = __webpack_require__(29);\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    /** @deprecated internal use only */ WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n/***/ }),\n\n/***/ 782:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar async_1 = __webpack_require__(283);\nvar Subscriber_1 = __webpack_require__(10);\nvar isNumeric_1 = __webpack_require__(288);\nvar isScheduler_1 = __webpack_require__(171);\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n/***/ }),\n\n/***/ 783:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar Subscription_1 = __webpack_require__(52);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n/***/ }),\n\n/***/ 784:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(169);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n/***/ }),\n\n/***/ 785:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ }),\n\n/***/ 786:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar zip_1 = __webpack_require__(699);\nfunction zipAll(project) {\n    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1-7fdf47014c421ba903fa.js","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof Intl !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser && (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) &&\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of `<input>` that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, supportsPassiveEventListeners, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { merge } from 'rxjs/observable/merge';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable.create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (!_this._scrolledCount) {\n                    _this._removeGlobalListener();\n                }\n            };\n        }) : of();\n    };\n    /**\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._removeGlobalListener();\n        this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._removeGlobalListener = /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    function () {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(_platform, ngZone) {\n        var _this = this;\n        this._platform = _platform;\n        this._change = _platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        var /** @type {?} */ output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = /** @type {?} */ ((null));\n        }\n        return output;\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = this._platform.isBrowser ?\n            { width: window.innerWidth, height: window.innerHeight } :\n            { width: 0, height: 0 };\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [CdkScrollable],\n                    declarations: [CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, EventEmitter, Input, NgModule, Output, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n * @template T\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n * @template T\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\nvar ComponentPortal = /** @class */ (function (_super) {\n    __extends(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n * @template C\n */\nvar TemplatePortal = /** @class */ (function (_super) {\n    __extends(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        _this.context = context;\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar DomPortalOutlet = /** @class */ (function (_super) {\n    __extends(DomPortalOutlet, _super);\n    function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this.outletElement = outletElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar CdkPortal = /** @class */ (function (_super) {\n    __extends(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return CdkPortal;\n}(TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nvar CdkPortalOutlet = /** @class */ (function (_super) {\n    __extends(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        _this.attached = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"attachedRef\", {\n        /** Component or view reference that is attached to the portal. */\n        get: /**\n         * Component or view reference that is attached to the portal.\n         * @return {?}\n         */\n        function () {\n            return this._attachedRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n        this._attachedRef = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: Input, args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: Input, args: ['cdkPortalHost',] },],\n        \"attached\": [{ type: Output, args: ['attached',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [CdkPortal, CdkPortalOutlet],\n                    declarations: [CdkPortal, CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * \\@docs-private\n * @param {?} value\n * @return {?}\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, _isNumberValue, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { __assign, __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config)\n                .filter(function (key) { return typeof config[key] !== 'undefined'; })\n                .forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = this._document.documentElement;\n            var /** @type {?} */ body = this._document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        var /** @type {?} */ html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = this._document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n        this._document = document;\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n        /** The overlay's backdrop HTML element. */\n        get: /**\n         * The overlay's backdrop HTML element.\n         * @return {?}\n         */\n        function () {\n            return this._backdropElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            // The overlay could've been detached before the zone has stabilized.\n            if (_this.hasAttached()) {\n                _this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = __assign({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = __assign({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () {\n                    if (_this._backdropElement) {\n                        _this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n        this._onPositionChange.complete();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.setOrigin = /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin.nativeElement;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        /**\n         * A lazily-created wrapper for the overlay element that is used as a flex container.\n         */\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @deletion-target 7.0.0\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@deletion-target 7.0.0\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        var /** @type {?} */ config = this._overlayRef.getConfig();\n        styles.position = this._cssPosition;\n        styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n        styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        parentStyles.justifyContent = config.width === '100%' ? 'flex-start' : this._justifyContent;\n        parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = fromEvent(this._document.body, 'keydown', true);\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to the correct overlay.\n            // Dispatch keydown event to the correct overlay.\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use the overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT)\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayContainer],\n        /** @type {?} */ (DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: OverlayKeyboardDispatcher, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._lockPosition = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"lockPosition\", {\n        get: /**\n         * Whether or not the overlay should be locked when scrolling.\n         * @return {?}\n         */\n        function () { return this._lockPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._lockPosition = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (this._position) {\n            if (changes['positions'] || changes['_deprecatedPositions']) {\n                this._position.withPositions(this.positions);\n            }\n            if (changes['lockPosition']) {\n                this._position.withLockedPosition(this.lockPosition);\n            }\n            if (changes['origin'] || changes['_deprecatedOrigin']) {\n                this._position.setOrigin(this.origin.elementRef);\n                if (this.open) {\n                    this._position.apply();\n                }\n            }\n        }\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ primaryPosition = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: primaryPosition.originX, originY: primaryPosition.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: primaryPosition.overlayX, overlayY: primaryPosition.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY)\n            .withLockedPosition(this.lockPosition);\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n        return strategy;\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {\n                _this.backdropClick.emit(event);\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"lockPosition\": [{ type: Input, args: ['cdkConnectedOverlayLockPosition',] },],\n        \"_deprecatedOrigin\": [{ type: Input, args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: Input, args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: Input, args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: Input, args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: Input, args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: Input, args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: Input, args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: Input, args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: Input, args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: Input, args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: Input, args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: Input, args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: Output },],\n        \"positionChange\": [{ type: Output },],\n        \"attach\": [{ type: Output },],\n        \"detach\": [{ type: Output },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [BidiModule, PortalModule, ScrollDispatchModule],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],\n                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = /** @class */ (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as g, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as f, OVERLAY_CONTAINER_PROVIDER as b, OVERLAY_CONTAINER_PROVIDER_FACTORY as a, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as c, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { take } from 'rxjs/operators/take';\nimport { Platform, PlatformModule, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, LEFT_ARROW, NINE, RIGHT_ARROW, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch (/** @type {?} */ e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n * \\@deletion-target 6.0.0\n */\nvar FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: Input, args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._canBeDescribed = /**\n     * Determines whether a message can be described on a particular element.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        return element.nodeType === this._document.ELEMENT_NODE && message != null &&\n            !!(\"\" + message).trim();\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n// unsupported: template constraints.\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n * @template T\n */\nvar ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = function (item) { return item.disabled; };\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n        _items.changes.subscribe(function (newItems) {\n            if (_this._activeItem) {\n                var /** @type {?} */ itemArray = newItems.toArray();\n                var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                    _this._activeItemIndex = newIndex;\n                }\n            }\n        });\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    ListKeyManager.prototype.skipPredicate = /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param {?} predicate Function that determines whether the given item should be skipped.\n     * @return {?}\n     */\n    function (predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    };\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        this._vertical = enabled;\n        return this;\n    };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    function (direction) {\n        this._horizontal = direction;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        for (var /** @type {?} */ i = 1; i <= items.length; i++) {\n            var /** @type {?} */ index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            var /** @type {?} */ item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\n/**\n * @template T\n */\nvar ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\n/**\n * @template T\n */\nvar FocusKeyManager = /** @class */ (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin;\n        return this;\n    };\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?} Promise that will be resolved when the message is added to the DOM.\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                _this._liveElement.textContent = message;\n                resolve();\n            }, 100);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof Renderer2)) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeoutId != null) {\n                clearTimeout(_this._touchTimeoutId);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(_this._windowFocusTimeoutId);\n            clearTimeout(_this._touchTimeoutId);\n            clearTimeout(_this._originTimeoutId);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkTrapFocus as FocusTrapDirective, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, CdkTrapFocus, InteractivityChecker, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.crt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.did(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.did(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), i0.qud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.eld(2, 0, null, null, 8, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), i0.did(3, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(5, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n        \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.did(8, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = \"dropdown open show ngx-contextmenu\"; var currVal_1 = _co.menuClass; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.menuItems; _ck(_v, 8, 0, currVal_2); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.nov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.did(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", menuClass: \"menuClass\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.crt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.did(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { menuClass: \"menuClass\", autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i5 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i7 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i8 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i10 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i12 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i13 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i14 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i16 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i17 from \"../demo-utils/calendar-header.component\";\nimport * as i18 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i19 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i22 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.crt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.nov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.did(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i1.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ppd(3, 3), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.unv(_v, 2, 0, _ck(_v, 3, 0, i0.nov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_3)), i0.did(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ted(10, null, [\"\", \"\"])), i0.ppd(11, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_4)), i0.did(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.nov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.unv(_v, 10, 0, _ck(_v, 11, 0, i0.nov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.did(1, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ted(4, null, [\"\", \"\"])), i0.ppd(5, 3), (_l()(), i0.eld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ted(9, null, [\"\", \"\"])), i0.ppd(10, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.nov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.unv(_v, 4, 0, _ck(_v, 5, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.unv(_v, 9, 0, _ck(_v, 10, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_6)), i0.did(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(3, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ted(6, null, [\"\\n      \", \"\\n    \"])), i0.ppd(7, 3), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.nov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.unv(_v, 6, 0, _ck(_v, 7, 0, i0.nov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i5.View_CalendarMonthViewComponent_0, i5.RenderType_CalendarMonthViewComponent)), i0.did(1, 770048, null, 0, i6.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i8.View_CalendarWeekViewComponent_0, i8.RenderType_CalendarWeekViewComponent)), i0.did(1, 770048, null, 0, i9.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i10.View_CalendarDayViewComponent_0, i10.RenderType_CalendarDayViewComponent)), i0.did(1, 770048, null, 0, i11.CalendarDayViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.vid(2, [i0.pid(0, i12.CalendarDatePipe, [i13.CalendarDateFormatter, i0.LOCALE_ID]), i0.pid(0, i14.CalendarEventTitlePipe, [i15.CalendarEventTitleFormatter]), (_l()(), i0.eld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i16.View_CalendarHeaderComponent_0, i16.RenderType_CalendarHeaderComponent)), i0.did(3, 49152, null, 0, i17.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i18.View_ContextMenuComponent_0, i18.RenderType_ContextMenuComponent)), i0.did(7, 180224, [[\"basicMenu\", 4]], 1, i19.ContextMenuComponent, [i4.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i20.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.did(11, 16384, [[1, 4]], 0, i21.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.did(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_8)), i0.did(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_9)), i0.did(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_10)), i0.did(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.did(1, 49152, null, 0, i22.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ccf(\"mwl-demo-component\", i22.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: Output, args: ['dirChange',] },],\n        \"dir\": [{ type: Input },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 57;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE, COMMA };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE, event: event });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit({ event: event });\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" [ngClass]=\\\"menuClass\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: Input },],\n        \"item\": [{ type: Input },],\n        \"event\": [{ type: Input },],\n        \"parentContextMenu\": [{ type: Input },],\n        \"menuClass\": [{ type: Input },],\n        \"overlay\": [{ type: Input },],\n        \"isLeaf\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n        \"openSubMenu\": [{ type: Output },],\n        \"closeLeafMenu\": [{ type: Output },],\n        \"closeAllMenus\": [{ type: Output },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n        \"menuItemElements\": [{ type: ViewChildren, args: ['li',] },],\n        \"onKeyEvent\": [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: Input },],\n        \"divider\": [{ type: Input },],\n        \"enabled\": [{ type: Input },],\n        \"passive\": [{ type: Input },],\n        \"visible\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            var mouseEvent_1 = event;\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: mouseEvent_1.clientY,\n                    height: 0,\n                    left: mouseEvent_1.clientX,\n                    right: mouseEvent_1.clientX,\n                    top: mouseEvent_1.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus({ eventType: 'cancel', event: event });\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems, menuClass = context.menuClass;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        contextMenuContent.instance.menuClass = menuClass;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function (executeEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'execute' }, executeEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function (closeAllEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'cancel' }, closeAllEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function (closeEvent) {\n        if (this.overlays) {\n            this.close.next(closeEvent);\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > 1 && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {\n                _this.close.next({ eventType: 'cancel', event: event });\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { first } from 'rxjs/operators';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.menuClass = \"\";\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) {\n            _this.onMenuEvent(menuEvent);\n        }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        var _this = this;\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));\n        this._contextMenuService.close.asObservable().pipe(first()).subscribe(function (closeEvent) { return _this.close.emit(closeEvent); });\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"menuClass\": [{ type: Input },],\n        \"autoFocus\": [{ type: Input },],\n        \"useBootstrap4\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"close\": [{ type: Output },],\n        \"open\": [{ type: Output },],\n        \"menuItems\": [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: Input },],\n        \"contextMenu\": [{ type: Input },],\n        \"onContextMenu\": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/bidi\";\nimport * as i8 from \"@angular/cdk/platform\";\nimport * as i9 from \"@angular/cdk/scrolling\";\nimport * as i10 from \"@angular/cdk/overlay\";\nimport * as i11 from \"@angular/forms\";\nimport * as i12 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i13 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i17 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i18 from \"angular-draggable-droppable\";\nimport * as i19 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i23 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i24 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i25 from \"angular-resizable-element\";\nimport * as i26 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i27 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i28 from \"../../../src/modules/calendar.module\";\nimport * as i29 from \"@angular/cdk/portal\";\nimport * as i30 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i31 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i32 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i33 from \"../demo-utils/module\";\nimport * as i34 from \"@angular/router\";\nimport * as i35 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i36 from \"./component\";\nvar DemoModuleNgFactory = i0.cmf(i1.DemoModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.a]]), i0.mpd(6144, i7.DIR_DOCUMENT, null, [i6.DOCUMENT]), i0.mpd(4608, i7.Directionality, i7.Directionality, [[2, i7.DIR_DOCUMENT]]), i0.mpd(4608, i8.Platform, i8.Platform, []), i0.mpd(5120, i9.ScrollDispatcher, i9.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i9.ScrollDispatcher], i0.NgZone, i8.Platform]), i0.mpd(5120, i9.ViewportRuler, i9.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i9.ViewportRuler], i8.Platform, i0.NgZone]), i0.mpd(4608, i10.ScrollStrategyOptions, i10.ScrollStrategyOptions, [i9.ScrollDispatcher, i9.ViewportRuler, i0.NgZone, i6.DOCUMENT]), i0.mpd(5120, i10.OverlayContainer, i10.a, [[3, i10.OverlayContainer], i6.DOCUMENT]), i0.mpd(4608, i10.OverlayPositionBuilder, i10.OverlayPositionBuilder, [i9.ViewportRuler, i6.DOCUMENT]), i0.mpd(5120, i10.OverlayKeyboardDispatcher, i10.f, [[3, i10.OverlayKeyboardDispatcher], i6.DOCUMENT]), i0.mpd(4608, i10.Overlay, i10.Overlay, [i10.ScrollStrategyOptions, i10.OverlayContainer, i0.ComponentFactoryResolver, i10.OverlayPositionBuilder, i10.OverlayKeyboardDispatcher, i0.ApplicationRef, i0.Injector, i0.NgZone, i6.DOCUMENT]), i0.mpd(5120, i10.c, i10.d, [i10.Overlay]), i0.mpd(4608, i11.i, i11.i, []), i0.mpd(4608, i12.NgbCalendar, i12.NgbCalendarGregorian, []), i0.mpd(4608, i13.NgbDatepickerI18n, i13.NgbDatepickerI18nDefault, []), i0.mpd(4608, i14.NgbDateParserFormatter, i14.NgbDateISOParserFormatter, []), i0.mpd(4608, i15.NgbDateAdapter, i15.NgbDateStructAdapter, []), i0.mpd(4608, i16.NgbDatepickerConfig, i16.NgbDatepickerConfig, []), i0.mpd(4608, i17.NgbTimepickerConfig, i17.NgbTimepickerConfig, []), i0.mpd(4608, i18.DraggableHelper, i18.DraggableHelper, []), i0.mpd(4608, i19.CalendarEventTitleFormatter, i19.CalendarEventTitleFormatter, []), i0.mpd(4608, i20.CalendarDateFormatter, i20.CalendarDateFormatter, []), i0.mpd(4608, i21.CalendarUtils, i21.CalendarUtils, []), i0.mpd(4608, i22.ContextMenuService, i22.ContextMenuService, [i10.Overlay, i10.ScrollStrategyOptions]), i0.mpd(512, i6.CommonModule, i6.CommonModule, []), i0.mpd(512, i23.CalendarCommonModule, i23.CalendarCommonModule, []), i0.mpd(512, i18.DragAndDropModule, i18.DragAndDropModule, []), i0.mpd(512, i24.CalendarMonthModule, i24.CalendarMonthModule, []), i0.mpd(512, i25.ResizableModule, i25.ResizableModule, []), i0.mpd(512, i26.CalendarWeekModule, i26.CalendarWeekModule, []), i0.mpd(512, i27.CalendarDayModule, i27.CalendarDayModule, []), i0.mpd(512, i28.CalendarModule, i28.CalendarModule, []), i0.mpd(512, i7.BidiModule, i7.BidiModule, []), i0.mpd(512, i29.PortalModule, i29.PortalModule, []), i0.mpd(512, i8.PlatformModule, i8.PlatformModule, []), i0.mpd(512, i9.ScrollDispatchModule, i9.ScrollDispatchModule, []), i0.mpd(512, i10.OverlayModule, i10.OverlayModule, []), i0.mpd(512, i30.ContextMenuModule, i30.ContextMenuModule, []), i0.mpd(512, i11.ba, i11.ba, []), i0.mpd(512, i11.FormsModule, i11.FormsModule, []), i0.mpd(512, i31.NgbDatepickerModule, i31.NgbDatepickerModule, []), i0.mpd(512, i32.NgbTimepickerModule, i32.NgbTimepickerModule, []), i0.mpd(512, i33.DemoUtilsModule, i33.DemoUtilsModule, []), i0.mpd(512, i34.RouterModule, i34.RouterModule, [[2, i34.a], [2, i34.Router]]), i0.mpd(512, i1.DemoModule, i1.DemoModule, []), i0.mpd(256, i35.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.mpd(1024, i34.ROUTES, function () { return [[{ path: \"\", component: i36.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 687\n// module chunks = 1","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar of_1 = require('./of');\nvar from_1 = require('./from');\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/concat.js\n// module id = 689\n// module chunks = 1","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/fromEvent.js\n// module id = 690\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 691\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 692\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 693\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 694\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/combineLatest.js\n// module id = 695\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/find.js\n// module id = 696\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar queue_1 = require('./scheduler/queue');\nvar Subscription_1 = require('./Subscription');\nvar observeOn_1 = require('./operators/observeOn');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    /** @deprecated internal use only */ ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/ReplaySubject.js\n// module id = 697\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    /** @deprecated internal use only */ SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchMap.js\n// module id = 698\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar Subscriber_1 = require('../Subscriber');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar iterator_1 = require('../symbol/iterator');\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/zip.js\n// module id = 699\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    /** @deprecated internal use only */ FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromEventObservable.js\n// module id = 703\n// module chunks = 1","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 704\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    /** @deprecated internal use only */ TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 705\n// module chunks = 1","\"use strict\";\nvar audit_1 = require('./operators/audit');\nexports.audit = audit_1.audit;\nvar auditTime_1 = require('./operators/auditTime');\nexports.auditTime = auditTime_1.auditTime;\nvar buffer_1 = require('./operators/buffer');\nexports.buffer = buffer_1.buffer;\nvar bufferCount_1 = require('./operators/bufferCount');\nexports.bufferCount = bufferCount_1.bufferCount;\nvar bufferTime_1 = require('./operators/bufferTime');\nexports.bufferTime = bufferTime_1.bufferTime;\nvar bufferToggle_1 = require('./operators/bufferToggle');\nexports.bufferToggle = bufferToggle_1.bufferToggle;\nvar bufferWhen_1 = require('./operators/bufferWhen');\nexports.bufferWhen = bufferWhen_1.bufferWhen;\nvar catchError_1 = require('./operators/catchError');\nexports.catchError = catchError_1.catchError;\nvar combineAll_1 = require('./operators/combineAll');\nexports.combineAll = combineAll_1.combineAll;\nvar combineLatest_1 = require('./operators/combineLatest');\nexports.combineLatest = combineLatest_1.combineLatest;\nvar concat_1 = require('./operators/concat');\nexports.concat = concat_1.concat;\nvar concatAll_1 = require('./operators/concatAll');\nexports.concatAll = concatAll_1.concatAll;\nvar concatMap_1 = require('./operators/concatMap');\nexports.concatMap = concatMap_1.concatMap;\nvar concatMapTo_1 = require('./operators/concatMapTo');\nexports.concatMapTo = concatMapTo_1.concatMapTo;\nvar count_1 = require('./operators/count');\nexports.count = count_1.count;\nvar debounce_1 = require('./operators/debounce');\nexports.debounce = debounce_1.debounce;\nvar debounceTime_1 = require('./operators/debounceTime');\nexports.debounceTime = debounceTime_1.debounceTime;\nvar defaultIfEmpty_1 = require('./operators/defaultIfEmpty');\nexports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\nvar delay_1 = require('./operators/delay');\nexports.delay = delay_1.delay;\nvar delayWhen_1 = require('./operators/delayWhen');\nexports.delayWhen = delayWhen_1.delayWhen;\nvar dematerialize_1 = require('./operators/dematerialize');\nexports.dematerialize = dematerialize_1.dematerialize;\nvar distinct_1 = require('./operators/distinct');\nexports.distinct = distinct_1.distinct;\nvar distinctUntilChanged_1 = require('./operators/distinctUntilChanged');\nexports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\nvar distinctUntilKeyChanged_1 = require('./operators/distinctUntilKeyChanged');\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\nvar elementAt_1 = require('./operators/elementAt');\nexports.elementAt = elementAt_1.elementAt;\nvar every_1 = require('./operators/every');\nexports.every = every_1.every;\nvar exhaust_1 = require('./operators/exhaust');\nexports.exhaust = exhaust_1.exhaust;\nvar exhaustMap_1 = require('./operators/exhaustMap');\nexports.exhaustMap = exhaustMap_1.exhaustMap;\nvar expand_1 = require('./operators/expand');\nexports.expand = expand_1.expand;\nvar filter_1 = require('./operators/filter');\nexports.filter = filter_1.filter;\nvar finalize_1 = require('./operators/finalize');\nexports.finalize = finalize_1.finalize;\nvar find_1 = require('./operators/find');\nexports.find = find_1.find;\nvar findIndex_1 = require('./operators/findIndex');\nexports.findIndex = findIndex_1.findIndex;\nvar first_1 = require('./operators/first');\nexports.first = first_1.first;\nvar groupBy_1 = require('./operators/groupBy');\nexports.groupBy = groupBy_1.groupBy;\nvar ignoreElements_1 = require('./operators/ignoreElements');\nexports.ignoreElements = ignoreElements_1.ignoreElements;\nvar isEmpty_1 = require('./operators/isEmpty');\nexports.isEmpty = isEmpty_1.isEmpty;\nvar last_1 = require('./operators/last');\nexports.last = last_1.last;\nvar map_1 = require('./operators/map');\nexports.map = map_1.map;\nvar mapTo_1 = require('./operators/mapTo');\nexports.mapTo = mapTo_1.mapTo;\nvar materialize_1 = require('./operators/materialize');\nexports.materialize = materialize_1.materialize;\nvar max_1 = require('./operators/max');\nexports.max = max_1.max;\nvar merge_1 = require('./operators/merge');\nexports.merge = merge_1.merge;\nvar mergeAll_1 = require('./operators/mergeAll');\nexports.mergeAll = mergeAll_1.mergeAll;\nvar mergeMap_1 = require('./operators/mergeMap');\nexports.mergeMap = mergeMap_1.mergeMap;\nvar mergeMap_2 = require('./operators/mergeMap');\nexports.flatMap = mergeMap_2.mergeMap;\nvar mergeMapTo_1 = require('./operators/mergeMapTo');\nexports.mergeMapTo = mergeMapTo_1.mergeMapTo;\nvar mergeScan_1 = require('./operators/mergeScan');\nexports.mergeScan = mergeScan_1.mergeScan;\nvar min_1 = require('./operators/min');\nexports.min = min_1.min;\nvar multicast_1 = require('./operators/multicast');\nexports.multicast = multicast_1.multicast;\nvar observeOn_1 = require('./operators/observeOn');\nexports.observeOn = observeOn_1.observeOn;\nvar onErrorResumeNext_1 = require('./operators/onErrorResumeNext');\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\nvar pairwise_1 = require('./operators/pairwise');\nexports.pairwise = pairwise_1.pairwise;\nvar partition_1 = require('./operators/partition');\nexports.partition = partition_1.partition;\nvar pluck_1 = require('./operators/pluck');\nexports.pluck = pluck_1.pluck;\nvar publish_1 = require('./operators/publish');\nexports.publish = publish_1.publish;\nvar publishBehavior_1 = require('./operators/publishBehavior');\nexports.publishBehavior = publishBehavior_1.publishBehavior;\nvar publishLast_1 = require('./operators/publishLast');\nexports.publishLast = publishLast_1.publishLast;\nvar publishReplay_1 = require('./operators/publishReplay');\nexports.publishReplay = publishReplay_1.publishReplay;\nvar race_1 = require('./operators/race');\nexports.race = race_1.race;\nvar reduce_1 = require('./operators/reduce');\nexports.reduce = reduce_1.reduce;\nvar repeat_1 = require('./operators/repeat');\nexports.repeat = repeat_1.repeat;\nvar repeatWhen_1 = require('./operators/repeatWhen');\nexports.repeatWhen = repeatWhen_1.repeatWhen;\nvar retry_1 = require('./operators/retry');\nexports.retry = retry_1.retry;\nvar retryWhen_1 = require('./operators/retryWhen');\nexports.retryWhen = retryWhen_1.retryWhen;\nvar refCount_1 = require('./operators/refCount');\nexports.refCount = refCount_1.refCount;\nvar sample_1 = require('./operators/sample');\nexports.sample = sample_1.sample;\nvar sampleTime_1 = require('./operators/sampleTime');\nexports.sampleTime = sampleTime_1.sampleTime;\nvar scan_1 = require('./operators/scan');\nexports.scan = scan_1.scan;\nvar sequenceEqual_1 = require('./operators/sequenceEqual');\nexports.sequenceEqual = sequenceEqual_1.sequenceEqual;\nvar share_1 = require('./operators/share');\nexports.share = share_1.share;\nvar shareReplay_1 = require('./operators/shareReplay');\nexports.shareReplay = shareReplay_1.shareReplay;\nvar single_1 = require('./operators/single');\nexports.single = single_1.single;\nvar skip_1 = require('./operators/skip');\nexports.skip = skip_1.skip;\nvar skipLast_1 = require('./operators/skipLast');\nexports.skipLast = skipLast_1.skipLast;\nvar skipUntil_1 = require('./operators/skipUntil');\nexports.skipUntil = skipUntil_1.skipUntil;\nvar skipWhile_1 = require('./operators/skipWhile');\nexports.skipWhile = skipWhile_1.skipWhile;\nvar startWith_1 = require('./operators/startWith');\nexports.startWith = startWith_1.startWith;\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\nvar switchAll_1 = require('./operators/switchAll');\nexports.switchAll = switchAll_1.switchAll;\nvar switchMap_1 = require('./operators/switchMap');\nexports.switchMap = switchMap_1.switchMap;\nvar switchMapTo_1 = require('./operators/switchMapTo');\nexports.switchMapTo = switchMapTo_1.switchMapTo;\nvar take_1 = require('./operators/take');\nexports.take = take_1.take;\nvar takeLast_1 = require('./operators/takeLast');\nexports.takeLast = takeLast_1.takeLast;\nvar takeUntil_1 = require('./operators/takeUntil');\nexports.takeUntil = takeUntil_1.takeUntil;\nvar takeWhile_1 = require('./operators/takeWhile');\nexports.takeWhile = takeWhile_1.takeWhile;\nvar tap_1 = require('./operators/tap');\nexports.tap = tap_1.tap;\nvar throttle_1 = require('./operators/throttle');\nexports.throttle = throttle_1.throttle;\nvar throttleTime_1 = require('./operators/throttleTime');\nexports.throttleTime = throttleTime_1.throttleTime;\nvar timeInterval_1 = require('./operators/timeInterval');\nexports.timeInterval = timeInterval_1.timeInterval;\nvar timeout_1 = require('./operators/timeout');\nexports.timeout = timeout_1.timeout;\nvar timeoutWith_1 = require('./operators/timeoutWith');\nexports.timeoutWith = timeoutWith_1.timeoutWith;\nvar timestamp_1 = require('./operators/timestamp');\nexports.timestamp = timestamp_1.timestamp;\nvar toArray_1 = require('./operators/toArray');\nexports.toArray = toArray_1.toArray;\nvar window_1 = require('./operators/window');\nexports.window = window_1.window;\nvar windowCount_1 = require('./operators/windowCount');\nexports.windowCount = windowCount_1.windowCount;\nvar windowTime_1 = require('./operators/windowTime');\nexports.windowTime = windowTime_1.windowTime;\nvar windowToggle_1 = require('./operators/windowToggle');\nexports.windowToggle = windowToggle_1.windowToggle;\nvar windowWhen_1 = require('./operators/windowWhen');\nexports.windowWhen = windowWhen_1.windowWhen;\nvar withLatestFrom_1 = require('./operators/withLatestFrom');\nexports.withLatestFrom = withLatestFrom_1.withLatestFrom;\nvar zip_1 = require('./operators/zip');\nexports.zip = zip_1.zip;\nvar zipAll_1 = require('./operators/zipAll');\nexports.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=operators.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators.js\n// module id = 706\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/buffer.js\n// module id = 707\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferCount.js\n// module id = 708\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferTime.js\n// module id = 709\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferToggle.js\n// module id = 710\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferWhen.js\n// module id = 711\n// module chunks = 1","\"use strict\";\nvar combineLatest_1 = require('../operators/combineLatest');\nfunction combineAll(project) {\n    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/combineAll.js\n// module id = 712\n// module chunks = 1","\"use strict\";\nvar concat_1 = require('../observable/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concat.js\n// module id = 713\n// module chunks = 1","\"use strict\";\nvar concatMap_1 = require('./concatMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concatMapTo.js\n// module id = 714\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return function (source) { return source.lift(new CountOperator(predicate, source)); };\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/count.js\n// module id = 715\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounce.js\n// module id = 716\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/delay.js\n// module id = 717\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Observable_1 = require('../Observable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\n                .lift(new DelayWhenOperator(delayDurationSelector));\n        };\n    }\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(/** @deprecated internal use only */ source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    /** @deprecated internal use only */ SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/delayWhen.js\n// module id = 718\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/dematerialize.js\n// module id = 719\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar Set_1 = require('../util/Set');\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/distinct.js\n// module id = 720\n// module chunks = 1","\"use strict\";\nvar root_1 = require('./root');\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/Set.js\n// module id = 721\n// module chunks = 1","\"use strict\";\nvar distinctUntilChanged_1 = require('./distinctUntilChanged');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/distinctUntilKeyChanged.js\n// module id = 722\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/elementAt.js\n// module id = 723\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return function (source) { return source.lift(new SwitchFirstOperator()); };\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/exhaust.js\n// module id = 724\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/exhaustMap.js\n// module id = 725\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/expand.js\n// module id = 726\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/finalize.js\n// module id = 727\n// module chunks = 1","\"use strict\";\nvar find_1 = require('../operators/find');\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/findIndex.js\n// module id = 728\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar Observable_1 = require('../Observable');\nvar Subject_1 = require('../Subject');\nvar Map_1 = require('../util/Map');\nvar FastMap_1 = require('../util/FastMap');\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    /** @deprecated internal use only */ GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    /** @deprecated internal use only */ GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/groupBy.js\n// module id = 729\n// module chunks = 1","\"use strict\";\nvar root_1 = require('./root');\nvar MapPolyfill_1 = require('./MapPolyfill');\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/Map.js\n// module id = 730\n// module chunks = 1","\"use strict\";\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/MapPolyfill.js\n// module id = 731\n// module chunks = 1","\"use strict\";\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/FastMap.js\n// module id = 732\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar noop_1 = require('../util/noop');\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nexports.ignoreElements = ignoreElements;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/ignoreElements.js\n// module id = 733\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nfunction isEmpty() {\n    return function (source) { return source.lift(new IsEmptyOperator()); };\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/isEmpty.js\n// module id = 734\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mapTo.js\n// module id = 735\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/materialize.js\n// module id = 736\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return reduce_1.reduce(max);\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/max.js\n// module id = 737\n// module chunks = 1","\"use strict\";\nvar merge_1 = require('../observable/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/merge.js\n// module id = 738\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mergeMapTo.js\n// module id = 739\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mergeScan.js\n// module id = 740\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return reduce_1.reduce(min);\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/min.js\n// module id = 741\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = require('../observable/FromObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/onErrorResumeNext.js\n// module id = 742\n// module chunks = 1","\"use strict\";\nvar not_1 = require('../util/not');\nvar filter_1 = require('./filter');\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return function (source) { return [\n        filter_1.filter(predicate, thisArg)(source),\n        filter_1.filter(not_1.not(predicate, thisArg))(source)\n    ]; };\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/partition.js\n// module id = 743\n// module chunks = 1","\"use strict\";\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/not.js\n// module id = 744\n// module chunks = 1","\"use strict\";\nvar map_1 = require('./map');\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return map_1.map(plucker(properties, length))(source); };\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/pluck.js\n// module id = 745\n// module chunks = 1","\"use strict\";\nvar Subject_1 = require('../Subject');\nvar multicast_1 = require('./multicast');\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publish.js\n// module id = 746\n// module chunks = 1","\"use strict\";\nvar BehaviorSubject_1 = require('../BehaviorSubject');\nvar multicast_1 = require('./multicast');\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishBehavior.js\n// module id = 747\n// module chunks = 1","\"use strict\";\nvar AsyncSubject_1 = require('../AsyncSubject');\nvar multicast_1 = require('./multicast');\nfunction publishLast() {\n    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishLast.js\n// module id = 748\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar Subscription_1 = require('./Subscription');\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    /** @deprecated internal use only */ AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/AsyncSubject.js\n// module id = 749\n// module chunks = 1","\"use strict\";\nvar ReplaySubject_1 = require('../ReplaySubject');\nvar multicast_1 = require('./multicast');\n/* tslint:enable:max-line-length */\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishReplay.js\n// module id = 750\n// module chunks = 1","\"use strict\";\nvar QueueAction_1 = require('./QueueAction');\nvar QueueScheduler_1 = require('./QueueScheduler');\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/queue.js\n// module id = 751\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/QueueAction.js\n// module id = 752\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/QueueScheduler.js\n// module id = 753\n// module chunks = 1","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nvar race_1 = require('../observable/race');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        // if the only argument is an array, it was most likely called with\n        // `pair([obs1, obs2, ...])`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.race = race;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/race.js\n// module id = 754\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.race = race;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/race.js\n// module id = 755\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/repeat.js\n// module id = 756\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            if (!this.retriesSubscription || this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/repeatWhen.js\n// module id = 757\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) { return source.lift(new RetryOperator(count, source)); };\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/retry.js\n// module id = 758\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    /** @deprecated internal use only */ RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/retryWhen.js\n// module id = 759\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sample.js\n// module id = 760\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sampleTime.js\n// module id = 761\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sequenceEqual.js\n// module id = 762\n// module chunks = 1","\"use strict\";\nvar ReplaySubject_1 = require('../ReplaySubject');\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n}\nexports.shareReplay = shareReplay;\nfunction shareReplayOperator(bufferSize, windowTime, scheduler) {\n    var subject;\n    var refCount = 0;\n    var subscription;\n    var hasError = false;\n    var isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next: function (value) { subject.next(value); },\n                error: function (err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete: function () {\n                    isComplete = true;\n                    subject.complete();\n                },\n            });\n        }\n        var innerSub = subject.subscribe(this);\n        return function () {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && refCount === 0 && isComplete) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n}\n;\n//# sourceMappingURL=shareReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/shareReplay.js\n// module id = 763\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/single.js\n// module id = 764\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skip.js\n// module id = 765\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipLast.js\n// module id = 766\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipUntil.js\n// module id = 767\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipWhile.js\n// module id = 768\n// module chunks = 1","\"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('../observable/concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/startWith.js\n// module id = 769\n// module chunks = 1","\"use strict\";\nvar switchMap_1 = require('./switchMap');\nvar identity_1 = require('../util/identity');\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchAll.js\n// module id = 770\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    /** @deprecated internal use only */ SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchMapTo.js\n// module id = 771\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/takeWhile.js\n// module id = 772\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nvar throttle_1 = require('./throttle');\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/throttleTime.js\n// module id = 773\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeInterval.js\n// module id = 774\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar TimeoutError_1 = require('../util/TimeoutError');\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeout.js\n// module id = 775\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/TimeoutError.js\n// module id = 776\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) {\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeoutWith.js\n// module id = 777\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar map_1 = require('./map');\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timestamp.js\n// module id = 778\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\nfunction toArrayReducer(arr, item, index) {\n    if (index === 0) {\n        return [item];\n    }\n    arr.push(item);\n    return arr;\n}\nfunction toArray() {\n    return reduce_1.reduce(toArrayReducer, []);\n}\nexports.toArray = toArray;\n//# sourceMappingURL=toArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/toArray.js\n// module id = 779\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    /** @deprecated internal use only */ WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/window.js\n// module id = 780\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subject_1 = require('../Subject');\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    /** @deprecated internal use only */ WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowCount.js\n// module id = 781\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isNumeric_1 = require('../util/isNumeric');\nvar isScheduler_1 = require('../util/isScheduler');\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowTime.js\n// module id = 782\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowToggle.js\n// module id = 783\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowWhen.js\n// module id = 784\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/withLatestFrom.js\n// module id = 785\n// module chunks = 1","\"use strict\";\nvar zip_1 = require('./zip');\nfunction zipAll(project) {\n    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/zipAll.js\n// module id = 786\n// module chunks = 1"],"sourceRoot":""}