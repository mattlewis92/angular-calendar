{"version":3,"sources":["webpack:///1-e37c33b22cbb493d52c3.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/@angular/cdk/esm5/rxjs.es5.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/operator/auditTime.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/operator/finally.js","webpack:///./node_modules/rxjs/operators/finalize.js","webpack:///./node_modules/rxjs/operator/do.js","webpack:///./node_modules/rxjs/operators/tap.js","webpack:///./node_modules/rxjs/operator/switchMap.js","webpack:///./node_modules/rxjs/operators/switchMap.js","webpack:///./node_modules/rxjs/operator/startWith.js","webpack:///./node_modules/rxjs/operators/startWith.js","webpack:///./node_modules/rxjs/observable/concat.js","webpack:///./node_modules/rxjs/operator/debounceTime.js","webpack:///./node_modules/rxjs/operators/debounceTime.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/operator/delay.js","webpack:///./node_modules/rxjs/operators/delay.js","webpack:///./node_modules/rxjs/observable/fromEvent.js","webpack:///./node_modules/rxjs/observable/FromEventObservable.js"],"names":["webpackJsonp","670","module","__webpack_exports__","__webpack_require__","coerceBooleanProperty","value","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","some","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","getAttribute","match","createMessageElement","message","messageElement","document","createElement","CDK_DESCRIBEDBY_ID_PREFIX","nextId","appendChild","createTextNode","messagesContainer","createMessagesContainer","messageRegistry","set","referenceCount","deleteMessageElement","registeredMessage","get","removeChild","delete","MESSAGES_CONTAINER_ID","style","display","body","deleteMessagesContainer","removeCdkDescribedByReferenceIds","element","originalReferenceIds","indexOf","addMessageReference","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","removeMessageReference","removeAttribute","isElementDescribedByMessage","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER_FACTORY","parentDispatcher","platform","a11y_es5_AriaDescriber","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","window","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","ngZone","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","ngForOf","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalHostAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalHostError","throwNoPortalAttachedError","SCROLL_DISPATCHER_PROVIDER_FACTORY","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrollDispatcher","scrolling_es5_ViewportRuler","DIRECTIONALITY_PROVIDER_FACTORY","parentDirectionality","_document","bidi_es5_Directionality","formatCssUnit","isElementScrolledOutsideView","scrollContainers","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","getMatScrollStrategyAlreadyAttachedError","MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","klass","ngClass","calendar_tooltip_directive","platform_browser","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","Object","defineProperty","DemoModule","calendar_tooltip_directive_ngfactory","Subscription","tslib_es6","Subject","operator_finally","operator_catch","operator_do","map","share","first","switchMap","startWith","debounceTime","auditTime","takeUntil","delay","RxChain","_context","this","from","prototype","call","operator","args","_i","arguments","apply","concat","subscribe","fn","result","doOperator","FinallyBrand","CatchBrand","DoBrand","MapBrand","FilterBrand","ShareBrand","FirstBrand","SwitchMapBrand","StartWithBrand","DebounceTimeBrand","AuditTimeBrand","TakeUntilBrand","DelayBrand","map$1","filter$1","first$1","debounceTime$1","hasV8BreakIterator","v8BreakIterator","platform_es5_Platform","Platform","isBrowser","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","providers","of","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","EMPTY","_pressedLetters","tabOut","withWrap","withTypeAhead","debounceInterval","_this","getLabel","unsubscribe","keyCode","inputString","items","toArray","i","index","disabled","toUpperCase","setActiveItem","_activeItem","onKeydown","setNextItemActive","setPreviousItemActive","next","key","toLocaleUpperCase","String","fromCharCode","preventDefault","enumerable","configurable","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","_super","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","Map","AriaDescriber","_platform","describe","hostElement","has","removeDescription","childNodes","ngOnDestroy","describedElements","querySelectorAll","clear","ARIA_DESCRIBER_PROVIDER","provide","deps","useFactory","a11y_es5_InteractivityChecker","FocusKeyManager","focus","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","_ngZone","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","destroy","parentNode","_createAnchor","runOutsideAngular","addEventListener","focusLastTabbableElement","focusFirstTabbableElement","insertBefore","nextSibling","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","root","children","tabbableChild","nodeType","Node","ELEMENT_NODE","anchor","classList","add","isStable","onStable","asObservable","a11y_es5_FocusTrapFactory","FocusTrapFactory","create","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_elementRef","_focusTrapFactory","focusTrap","nativeElement","enabled","ngAfterContentInit","selector","propDecorators","a11y_es5_FocusTrapDirective","FocusTrapDirective","exportAs","LIVE_ANNOUNCER_ELEMENT_TOKEN","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","setTimeout","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_origin","_windowFocused","_elementInfo","WeakMap","_registerDocumentEvents","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","focusListener","_onFocus","blurListener","_onBlur","removeEventListener","stopMonitoring","elementInfo","complete","_setClasses","focusVia","origin","_setOriginForCurrentEventQueue","_lastTouchTarget","_touchTimeout","clearTimeout","target","toggleClass","className","shouldSet","addClass","removeClass","_wasCausedByTouch","focusTarget","contains","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","imports","declarations","exports","assign","t","s","n","p","hasOwnProperty","ContextMenuContentComponent","changeDetector","elementRef","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","subscription","ngOnInit","forEach","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","updatePosition","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","Portal","attach","host","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","ComponentPortal","viewContainerRef","injector","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalHost","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","_disposeFn","portal_es5_DomPortalHost","DomPortalHost","_hostDomElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","attachView","hostView","detachView","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","remove","portal_es5_TemplatePortalDirective","TemplatePortalDirective","portal_es5_PortalHostDirective","PortalHostDirective","_viewContainerRef","_portal","v","ref","inputs","_deprecatedPortal","portal_es5_PortalModule","PortalModule","fromEvent","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","merge","ScrollDispatcher","_scrolled","_globalSubscription","_scrolledCount","scrollableReferences","register","scrollable","scrollSubscription","elementScrolled","_notify","deregister","scrollableReference","scrolled","auditTimeInMs","callback","observable","size","getScrollContainers","scrollingContainers","_subscription","scrollableContainsElement","scrollableElement","getElementRef","parentElement","SCROLL_DISPATCHER_PROVIDER","scrolling_es5_Scrollable","Scrollable","_scroll","_renderer","_elementScrolled","_scrollListener","listen","ViewportRuler","_change","_invalidateCacheSubscriptions","_cacheViewportGeometry","change","getViewportRect","documentRect","_documentRect","scrollPosition","getViewportScrollPosition","height","innerHeight","width","innerWidth","scrollTop","scrollY","documentElement","scrollLeft","scrollX","throttleTime","getBoundingClientRect","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","DIR_DOCUMENT","Directionality","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","old","useExisting","[dir]","NoopScrollStrategy","BidiModule","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","overlay_es5_OverlayRef","OverlayRef","_portalHost","_pane","_config","_backdropElement","_backdropClick","_attachments","_detachments","attachResult","positionStrategy","_updateStackingOrder","updateSize","updateDirection","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","backdropClick","attachments","detachments","getConfig","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","requestAnimationFrame","backdropToDetach","finishDetach_1","ConnectionPositionPair","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_viewportRuler","_offsetX","_offsetY","scrollables","_resizeSubscription","_preferredPositions","_onPositionChange","withFallbackPosition","overlayRef","_overlayRef","overlayElement","fallbackPoint","fallbackPosition","originRect","overlayRect","viewportRect","_a","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","_lastConnectedPosition","visibleArea","recalculateLastPosition","lastPosition","withScrollableContainers","withDirection","withOffsetX","offset","withOffsetY","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","positionChange","overflows","reduce","currentValue","currentOverflow","Math","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","parentStyles","position","marginTop","marginLeft","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayContainer","_containerElement","getContainerElement","_createContainer","container","OVERLAY_CONTAINER_PROVIDER","CloseScrollStrategy","_scrollDispatcher","_scrollSubscription","BlockScrollStrategy","_previousHTMLStyles","_isEnabled","_canBeEnabled","_previousScrollPosition","scroll","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","throttle","scrollThrottle","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","nextUniqueId","defaultConfig","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalHost","_createPortalHost","defaultPositionList","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY","MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_OverlayOrigin","OverlayOrigin","overlay_es5_ConnectedOverlayDirective","ConnectedOverlayDirective","_overlay","_scrollStrategy","_hasBackdrop","_backdropSubscription","_positionSubscription","_escapeListener","open","_templatePortal","offsetX","_position","offsetY","positions","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","strategy","_handlePositionChanges","onPositionChange","_initEscapeListener","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","attachContextMenu","clientY","clientX","closeAllContextMenus","contextMenuContent","instance","subscriptions","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","getLastAttachedOverlay","slice","newLeaf","subMenuOverlay","isLeafMenu","ContextMenuAttachDirective","contextMenuService","ContextMenuItemDirective","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","datepicker_config","timepicker_config","draggable_helper_provider","calendar_common_module","drag_and_drop_module","calendar_month_module","resizable_module","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","711","duration","scheduler","async_1","async","auditTime_1","712","isDate","716","_finally","finalize_1","finalize","717","source","lift","FinallyOperator","__extends","b","__","constructor","Subscriber_1","Subscription_1","subscriber","FinallySubscriber","destination","Subscriber","718","_do","nextOrObserver","error","tap_1","tap","719","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","_next","syncErrorThrown","syncErrorValue","_error","err","_complete","720","project","resultSelector","switchMap_1","721","SwitchMapOperator","OuterSubscriber_1","subscribeToResult_1","SwitchMapSubscriber","_innerSub","innerSubscription","subscribeToResult","closed","_unsubscribe","notifyComplete","innerSub","isStopped","notifyNext","outerValue","innerValue","outerIndex","innerIndex","_tryNotifyNext","OuterSubscriber","722","array","startWith_1","723","isScheduler_1","isScheduler","pop","len","concat_1","ScalarObservable_1","ScalarObservable","ArrayObservable_1","ArrayObservable","EmptyObservable_1","EmptyObservable","724","observables","from_1","concatAll_1","concatAll","of_1","725","dueTime","debounceTime_1","726","DebounceTimeOperator","dispatchNext","debouncedNext","DebounceTimeSubscriber","debouncedSubscription","lastValue","hasValue","clearDebounce","schedule","727","audit_1","audit","timer_1","timer","728","durationSelector","AuditOperator","tryCatch_1","errorObject_1","AuditSubscriber","throttled","tryCatch","errorObject","e","clearThrottle","729","TimerObservable_1","TimerObservable","730","isNumeric_1","Observable_1","isDate_1","period","isNumeric","Number","now","initialDelay","dispatch","state","action","_subscribe","Observable","731","delay_1","732","absoluteDelay","delayFor","abs","DelayOperator","Notification_1","DelaySubscriber","queue","active","errored","time","shift","notification","observe","_schedule","scheduleNotification","DelayMessage","Notification","createNext","createComplete","733","FromEventObservable_1","FromEventObservable","734","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","toString","isHTMLCollection","isEventTarget","isFunction_1","eventName","isFunction","setupSubscription","handler","source_1","source_2","TypeError","source_3"],"mappings":"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","file":"1-e37c33b22cbb493d52c3.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 670:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(286);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(58);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"y\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(24);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/finally.js\nvar operator_finally = __webpack_require__(716);\nvar finally_default = /*#__PURE__*/__webpack_require__.n(operator_finally);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/catch.js\nvar operator_catch = __webpack_require__(306);\nvar catch_default = /*#__PURE__*/__webpack_require__.n(operator_catch);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/do.js\nvar operator_do = __webpack_require__(718);\nvar do_default = /*#__PURE__*/__webpack_require__.n(operator_do);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/map.js\nvar map = __webpack_require__(119);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/filter.js\nvar filter = __webpack_require__(120);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/share.js\nvar share = __webpack_require__(176);\nvar share_default = /*#__PURE__*/__webpack_require__.n(share);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/first.js\nvar first = __webpack_require__(308);\nvar first_default = /*#__PURE__*/__webpack_require__.n(first);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/switchMap.js\nvar switchMap = __webpack_require__(720);\nvar switchMap_default = /*#__PURE__*/__webpack_require__.n(switchMap);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/startWith.js\nvar startWith = __webpack_require__(722);\nvar startWith_default = /*#__PURE__*/__webpack_require__.n(startWith);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/debounceTime.js\nvar debounceTime = __webpack_require__(725);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/auditTime.js\nvar auditTime = __webpack_require__(711);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/takeUntil.js\nvar takeUntil = __webpack_require__(301);\nvar takeUntil_default = /*#__PURE__*/__webpack_require__.n(takeUntil);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operator/delay.js\nvar delay = __webpack_require__(731);\nvar delay_default = /*#__PURE__*/__webpack_require__.n(delay);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/rxjs.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Utility class used to chain RxJS operators.\n *\n * This class is the concrete implementation, but the type used by the user when chaining\n * is StrictRxChain. The strict chain enforces types on the operators to the same level as\n * the prototype-added equivalents.\n */\nvar RxChain = (function () {\n    /**\n     * @param {?} _context\n     */\n    function RxChain(_context) {\n        this._context = _context;\n    }\n    /**\n     * Starts a new chain and specifies the initial `this` value.\n     * @template O\n     * @param {?} context Initial `this` value for the chain.\n     * @return {?}\n     */\n    RxChain.from = function (context) {\n        return new RxChain(context);\n    };\n    /**\n     * Invokes an RxJS operator as a part of the chain.\n     * @param {?} operator Operator to be invoked.\n     * @param {...?} args Arguments to be passed to the operator.\n     * @return {?}\n     */\n    RxChain.prototype.call = function (operator) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this._context = operator.call.apply(operator, [this._context].concat(args));\n        return this;\n    };\n    /**\n     * Subscribes to the result of the chain.\n     * @param {?} fn Callback to be invoked when the result emits a value.\n     * @return {?}\n     */\n    RxChain.prototype.subscribe = function (fn) {\n        return this._context.subscribe(fn);\n    };\n    /**\n     * Returns the result of the chain.\n     * @return {?}\n     */\n    RxChain.prototype.result = function () {\n        return this._context;\n    };\n    return RxChain;\n}());\n\nvar FinallyBrand = (function () {\n    function FinallyBrand() {\n    }\n    return FinallyBrand;\n}());\nvar CatchBrand = (function () {\n    function CatchBrand() {\n    }\n    return CatchBrand;\n}());\nvar DoBrand = (function () {\n    function DoBrand() {\n    }\n    return DoBrand;\n}());\nvar MapBrand = (function () {\n    function MapBrand() {\n    }\n    return MapBrand;\n}());\nvar FilterBrand = (function () {\n    function FilterBrand() {\n    }\n    return FilterBrand;\n}());\nvar ShareBrand = (function () {\n    function ShareBrand() {\n    }\n    return ShareBrand;\n}());\nvar FirstBrand = (function () {\n    function FirstBrand() {\n    }\n    return FirstBrand;\n}());\nvar SwitchMapBrand = (function () {\n    function SwitchMapBrand() {\n    }\n    return SwitchMapBrand;\n}());\nvar StartWithBrand = (function () {\n    function StartWithBrand() {\n    }\n    return StartWithBrand;\n}());\nvar DebounceTimeBrand = (function () {\n    function DebounceTimeBrand() {\n    }\n    return DebounceTimeBrand;\n}());\nvar AuditTimeBrand = (function () {\n    function AuditTimeBrand() {\n    }\n    return AuditTimeBrand;\n}());\nvar TakeUntilBrand = (function () {\n    function TakeUntilBrand() {\n    }\n    return TakeUntilBrand;\n}());\nvar DelayBrand = (function () {\n    function DelayBrand() {\n    }\n    return DelayBrand;\n}());\n// We add `Function` to the type intersection to make this nomically different from\n// `finallyOperatorType` while still being structurally the same. Without this, TypeScript tries to\n// reduce `typeof _finallyOperator & FinallyBrand` to `finallyOperatorType<T>` and then fails\n// because `T` isn't known.\nvar finallyOperator = (operator_finally[\"_finally\"]);\nvar catchOperator = (operator_catch[\"_catch\"]);\nvar doOperator = (operator_do[\"_do\"]);\nvar map$1 = (map[\"map\"]);\nvar filter$1 = (filter[\"filter\"]);\nvar share$1 = (share[\"share\"]);\nvar first$1 = (first[\"first\"]);\nvar switchMap$1 = (switchMap[\"switchMap\"]);\nvar startWith$1 = (startWith[\"startWith\"]);\nvar debounceTime$1 = (debounceTime[\"debounceTime\"]);\nvar auditTime$1 = (auditTime[\"auditTime\"]);\nvar takeUntil$1 = (takeUntil[\"takeUntil\"]);\nvar delay$1 = (delay[\"delay\"]);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=rxjs.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && ((Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n * \\@docs-private\n */\nvar platform_es5_Platform = (function () {\n    function Platform() {\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Layout Engines\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n        this.BLINK = this.isBrowser &&\n            (!!(((window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n        // ensure that Webkit runs standalone and is not used as another engine's base.\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Browsers and Platform Types\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\n        // instead of having an unstable check for Gecko.\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n        // Safari browser should also use Webkit as its layout engine.\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\nvar platform_es5_PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * Coerces a data-bound value (typically a string) to a number.\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(296);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar a11y_es5_ListKeyManager = (function () {\n    /**\n     * @param {?} _items\n     */\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = RxChain.from(this._letterKeyStream)\n            .call(doOperator, function (keyCode) { return _this._pressedLetters.push(keyCode); })\n            .call(debounceTime$1, debounceInterval)\n            .call(filter$1, function () { return _this._pressedLetters.length > 0; })\n            .call(map$1, function () { return _this._pressedLetters.join(''); })\n            .subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = function (index) {\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        get: function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /**\n         * The active item.\n         * @return {?}\n         */\n        get: function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\nvar a11y_es5_ActiveDescendantKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = (function () {\n    /**\n     * @param {?} _platform\n     */\n    function AriaDescriber(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            createMessageElement(message);\n        }\n        if (!isElementDescribedByMessage(hostElement, message)) {\n            addMessageReference(hostElement, message);\n        }\n    };\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (isElementDescribedByMessage(hostElement, message)) {\n            removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            deleteMessagesContainer();\n        }\n    };\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = function () {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        var /** @type {?} */ describedElements = document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * Creates a new element in the visually hidden message container element with the message\n * as its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message) {\n    var /** @type {?} */ messageElement = document.createElement('div');\n    messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n    messageElement.appendChild(/** @type {?} */ ((document.createTextNode(message))));\n    if (!messagesContainer) {\n        createMessagesContainer();\n    } /** @type {?} */\n    ((messagesContainer)).appendChild(messageElement);\n    messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message) {\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n    if (messagesContainer && messageElement) {\n        messagesContainer.removeChild(messageElement);\n    }\n    messageRegistry.delete(message);\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\n    messagesContainer = document.createElement('div');\n    messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n    messagesContainer.setAttribute('aria-hidden', 'true');\n    messagesContainer.style.display = 'none';\n    document.body.appendChild(messagesContainer);\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\n    document.body.removeChild(/** @type {?} */ ((messagesContainer)));\n    messagesContainer = null;\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element) {\n    // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n    var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n        .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n    element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = ((messageRegistry.get(message)));\n    // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\n    addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n    registeredMessage.referenceCount++;\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = ((messageRegistry.get(message)));\n    registeredMessage.referenceCount--;\n    removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element, message) {\n    var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n    return !!messageId && referenceIds.indexOf(messageId) != -1;\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, platform) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(platform);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        platform_es5_Platform\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\nvar a11y_es5_FocusKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = (function () {\n    /**\n     * @param {?} _platform\n     */\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && ((element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * NOTE: This class currently uses a very simple (naive) approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n * This will be replaced with a more intelligent solution before the library is considered stable.\n */\nvar a11y_es5_FocusTrap = (function () {\n    /**\n     * @param {?} _element\n     * @param {?} _platform\n     * @param {?} _checker\n     * @param {?} _ngZone\n     * @param {?=} deferAnchors\n     */\n    function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._platform = _platform;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return this._enabled; },\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = function () {\n        var _this = this;\n        // If we're not on the browser, there can be no focus to trap.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdk-focus-region-\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = function () {\n        var /** @type {?} */ redirectToElement = (this._element.querySelector('[cdk-focus-initial]'));\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = function () {\n        var /** @type {?} */ anchor = document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            first$1.call(this._ngZone.onStable.asObservable()).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = (function () {\n    /**\n     * @param {?} _checker\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    function FocusTrapFactory(_checker, _platform, _ngZone) {\n        this._checker = _checker;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} deferAnchors\n     * @return {?}\n     */\n    FocusTrapFactory.prototype.create = function (element, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        return new a11y_es5_FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * @deprecated\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusTrapFactory\n     */\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return !this.focusTrap.enabled; },\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        'disabled': [{ type: core[\"A\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_FocusTrapDirective = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusTrapFactory\n     */\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return this.focusTrap.enabled; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngOnDestroy = function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngAfterContentInit = function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDirective.propDecorators = {\n        'enabled': [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocus',] },],\n    };\n    return FocusTrapDirective;\n}());\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"y\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = (function () {\n    /**\n     * @param {?} elementToken\n     * @param {?} platform\n     */\n    function LiveAnnouncer(elementToken, platform) {\n        // Only do anything if we're on the browser platform.\n        if (platform.isBrowser) {\n            // We inject the live element as `any` because the constructor signature cannot reference\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n            // causes TypeScript to preserve the constructor signature types.\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = function () {\n        var /** @type {?} */ liveEl = document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: platform_es5_Platform, },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, platform);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"K\" /* Optional */](), new core[\"w\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        platform_es5_Platform,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = (function () {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _platform\n     */\n    function FocusMonitor(_ngZone, _platform) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = function (element, renderer, checkChildren) {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            renderer: renderer,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerDocumentEvents = function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        // On keydown record the origin and clear any touch event that may be in progress.\n        document.addEventListener('keydown', function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        }, true);\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        document.addEventListener('mousedown', function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        }, true);\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        document.addEventListener('touchstart', function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        }, true);\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        window.addEventListener('focus', function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        });\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            var /** @type {?} */ toggleClass = function (className, shouldSet) {\n                shouldSet ? elementInfo.renderer.addClass(element, className) :\n                    elementInfo.renderer.removeClass(element, className);\n            };\n            toggleClass('cdk-focused', !!origin);\n            toggleClass('cdk-touch-focused', origin === 'touch');\n            toggleClass('cdk-keyboard-focused', origin === 'keyboard');\n            toggleClass('cdk-mouse-focused', origin === 'mouse');\n            toggleClass('cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, renderer,  'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusMonitor\n     * @param {?} renderer\n     */\n    function CdkMonitorFocus(_elementRef, _focusMonitor, renderer) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"s\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n        { type: core[\"S\" /* Renderer2 */], },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        'cdkFocusChange': [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\nvar a11y_es5_A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_FocusTrapDirective, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_FocusTrapDirective, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = /** @class */ (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"s\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"P\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"R\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        'menuItems': [{ type: core[\"A\" /* Input */] },],\n        'item': [{ type: core[\"A\" /* Input */] },],\n        'event': [{ type: core[\"A\" /* Input */] },],\n        'parentContextMenu': [{ type: core[\"A\" /* Input */] },],\n        'overlay': [{ type: core[\"A\" /* Input */] },],\n        'isLeaf': [{ type: core[\"A\" /* Input */] },],\n        'execute': [{ type: core[\"L\" /* Output */] },],\n        'openSubMenu': [{ type: core[\"L\" /* Output */] },],\n        'closeLeafMenu': [{ type: core[\"L\" /* Output */] },],\n        'closeAllMenus': [{ type: core[\"L\" /* Output */] },],\n        'menuElement': [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n        'menuItemElements': [{ type: core[\"_5\" /* ViewChildren */], args: ['li',] },],\n        'onKeyEvent': [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        'keyboardOpenSubMenu': [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        'keyboardMenuItemSelect': [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        'onCloseLeafMenu': [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        'closeMenu': [{ type: core[\"v\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_22\" /* did */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_22\" /* did */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), core[\"_43\" /* qud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_22\" /* did */](7, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_37\" /* nov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_22\" /* did */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"R\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(287);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(85);\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/esm5/platform-browser.js\nvar platform_browser = __webpack_require__(34);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalHostAlreadyDisposedError() {\n    throw Error('This PortalHost has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalHost accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalHostError() {\n    throw Error('Attempting to attach a portal to a null PortalHost');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalHost`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = function (host) {\n        if (host == null) {\n            throwNullPortalHostError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return (host.attach(this));\n    };\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        get: function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar portal_es5_ComponentPortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    /**\n     * @param {?} component\n     * @param {?=} viewContainerRef\n     * @param {?=} injector\n     */\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar portal_es5_TemplatePortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    /**\n     * @param {?} template\n     * @param {?} viewContainerRef\n     * @param {?=} context\n     */\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalHost`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * Partial implementation of PortalHost that only deals with attaching either a\n * ComponentPortal or a TemplatePortal.\n * @abstract\n */\nvar BasePortalHost = (function () {\n    function BasePortalHost() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalHost.prototype.hasAttached = function () {\n        return !!this._attachedPortal;\n    };\n    /**\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attach = function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalHostAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /**\n     * @abstract\n     * @template T\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attachComponentPortal = function (portal) { };\n    /**\n     * @abstract\n     * @template C\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attachTemplatePortal = function (portal) { };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.detach = function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.dispose = function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype._invokeDisposeFn = function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalHost;\n}());\n\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar portal_es5_DomPortalHost = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalHost, _super);\n    /**\n     * @param {?} _hostDomElement\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _defaultInjector\n     */\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachComponentPortal = function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)\n        // To move the view to the specified host element. We just re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalHost.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\n        return (((componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalHost;\n}(BasePortalHost));\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n *\n * Usage:\n * <ng-template portal #greeting>\n *   <p> Hello {{name}} </p>\n * </ng-template>\n */\nvar portal_es5_TemplatePortalDirective = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortalDirective, _super);\n    /**\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     */\n    function TemplatePortalDirective(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    TemplatePortalDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    TemplatePortalDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    return TemplatePortalDirective;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalHost]=\"greeting\"></ng-template>\n */\nvar portal_es5_PortalHostDirective = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(PortalHostDirective, _super);\n    /**\n     * @param {?} _componentFactoryResolver\n     * @param {?} _viewContainerRef\n     */\n    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * The attached portal.\n         */\n        _this._portal = null;\n        return _this;\n    }\n    Object.defineProperty(PortalHostDirective.prototype, \"_deprecatedPortal\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.portal; },\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        set: function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PortalHostDirective.prototype, \"portal\", {\n        /**\n         * Portal associated with the Portal host.\n         * @return {?}\n         */\n        get: function () {\n            return this._portal;\n        },\n        /**\n         * @param {?} portal\n         * @return {?}\n         */\n        set: function (portal) {\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._portal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    PortalHostDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.dispose.call(this);\n        this._portal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal host.\n     * @return {?}\n     */\n    PortalHostDirective.prototype.attachComponentPortal = function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalHost.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._portal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?}\n     */\n    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._portal = portal;\n        return viewRef;\n    };\n    PortalHostDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalHost',\n                    inputs: ['portal: cdkPortalHost']\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PortalHostDirective.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    PortalHostDirective.propDecorators = {\n        '_deprecatedPortal': [{ type: core[\"A\" /* Input */], args: ['portalHost',] },],\n    };\n    return PortalHostDirective;\n}(BasePortalHost));\nvar portal_es5_PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [portal_es5_TemplatePortalDirective, portal_es5_PortalHostDirective],\n                    declarations: [portal_es5_TemplatePortalDirective, portal_es5_PortalHostDirective],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    /**\n     * @param {?} _parentInjector\n     * @param {?} _customTokens\n     */\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(733);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(122);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = (function () {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _platform\n     */\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollableReferences = new Map();\n    }\n    /**\n     * Registers a Scrollable with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event in its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });\n        this.scrollableReferences.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollableReferences.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollableReferences.delete(scrollable);\n        }\n    };\n    /**\n     * Subscribes to an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @param {?=} callback\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs, callback) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        // Scroll events can only happen on the browser, so do nothing if we're not on the browser.\n        if (!this._platform.isBrowser) {\n            return Subscription[\"Subscription\"].EMPTY;\n        }\n        // In the case of a 0ms delay, use an observable without auditTime\n        // since it does add a perceptible delay in processing overhead.\n        var /** @type {?} */ observable = auditTimeInMs > 0 ?\n            auditTime[\"auditTime\"].call(this._scrolled.asObservable(), auditTimeInMs) :\n            this._scrolled.asObservable();\n        this._scrolledCount++;\n        if (!this._globalSubscription) {\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n                return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._notify(); });\n            });\n        }\n        // Note that we need to do the subscribing from here, in order to be able to remove\n        // the global event listeners once there are no more subscriptions.\n        var /** @type {?} */ subscription = observable.subscribe(callback);\n        subscription.add(function () {\n            _this._scrolledCount--;\n            if (_this._globalSubscription && !_this.scrollableReferences.size && !_this._scrolledCount) {\n                _this._globalSubscription.unsubscribe();\n                _this._globalSubscription = null;\n            }\n        });\n        return subscription;\n    };\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollableReferences.forEach(function (_subscription, scrollable) {\n            if (_this.scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sends a notification that a scroll event has been fired.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._notify = function () {\n        this._scrolled.next();\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_Scrollable = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _scroll\n     * @param {?} _ngZone\n     * @param {?} _renderer\n     */\n    function Scrollable(_elementRef, _scroll, _ngZone, _renderer) {\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._renderer = _renderer;\n        this._elementScrolled = new Subject[\"Subject\"]();\n    }\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.ngOnInit = function () {\n        var _this = this;\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\n            return _this._renderer.listen(_this.getElementRef().nativeElement, 'scroll', function (event) {\n                _this._elementScrolled.next(event);\n            });\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.ngOnDestroy = function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this._scrollListener();\n            this._scrollListener = null;\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    Scrollable.prototype.elementScrolled = function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.getElementRef = function () {\n        return this._elementRef;\n    };\n    Scrollable.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Scrollable.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: core[\"S\" /* Renderer2 */], },\n    ]; };\n    return Scrollable;\n}());\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = (function () {\n    /**\n     * @param {?} platform\n     * @param {?} ngZone\n     * @param {?} scrollDispatcher\n     */\n    function ViewportRuler(platform, ngZone, scrollDispatcher) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        // Subscribe to scroll and resize events and update the document rectangle on changes.\n        this._invalidateCacheSubscriptions = [\n            scrollDispatcher.scrolled(0, function () { return _this._cacheViewportGeometry(); }),\n            this.change().subscribe(function () { return _this._cacheViewportGeometry(); })\n        ];\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = function () {\n        this._invalidateCacheSubscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });\n    };\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @param {?=} documentRect\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = function (documentRect) {\n        if (documentRect === void 0) { documentRect = this._documentRect; }\n        // Cache the document bounding rect so that we don't recompute it for multiple calls.\n        if (!documentRect) {\n            this._cacheViewportGeometry();\n            documentRect = this._documentRect;\n        }\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\n        var /** @type {?} */ height = window.innerHeight;\n        var /** @type {?} */ width = window.innerWidth;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @param {?=} documentRect\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {\n        if (documentRect === void 0) { documentRect = this._documentRect; }\n        // Cache the document bounding rect so that we don't recompute it for multiple calls.\n        if (!documentRect) {\n            this._cacheViewportGeometry();\n            documentRect = this._documentRect;\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ top = -((documentRect)).top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -((documentRect)).left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? auditTime[\"auditTime\"].call(this._change, throttleTime) : this._change;\n    };\n    /**\n     * Caches the latest client rectangle of the document element.\n     * @return {?}\n     */\n    ViewportRuler.prototype._cacheViewportGeometry = function () {\n        this._documentRect = document.documentElement.getBoundingClientRect();\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @param {?} scrollDispatcher\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone, scrollDispatcher) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone, scrollDispatcher);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */], scrolling_es5_ScrollDispatcher],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\nvar scrolling_es5_ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_Scrollable],\n                    declarations: [scrolling_es5_Scrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"y\" /* InjectionToken */]('mat-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = (function () {\n    /**\n     * @param {?=} _document\n     */\n    function Directionality(_document) {\n        this.value = 'ltr';\n        this.change = new core[\"s\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var bodyDir = _document.body ? _document.body.dir : null;\n            var htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = (bodyDir || htmlDir || 'ltr');\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDirectionality\n * @param {?} _document\n * @return {?}\n */\nfunction DIRECTIONALITY_PROVIDER_FACTORY(parentDirectionality, _document) {\n    return parentDirectionality || new bidi_es5_Directionality(_document);\n}\n/**\n * \\@docs-private\n */\nvar DIRECTIONALITY_PROVIDER = {\n    // If there is already a Directionality available, use that. Otherwise, provide a new one.\n    provide: bidi_es5_Directionality,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), bidi_es5_Directionality], [new core[\"K\" /* Optional */](), platform_browser[\"b\" /* DOCUMENT */]]],\n    useFactory: DIRECTIONALITY_PROVIDER_FACTORY\n};\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Would provide itself in case a component looks for the Directionality service\n */\nvar bidi_es5_Dir = (function () {\n    function Dir() {\n        /**\n         * Layout direction of the element.\n         */\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        /**\n         * \\@docs-private\n         * @return {?}\n         */\n        get: function () {\n            return this._dir;\n        },\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        set: function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        get: function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        'change': [{ type: core[\"L\" /* Output */], args: ['dirChange',] },],\n        'dir': [{ type: core[\"A\" /* Input */], args: ['dir',] },],\n    };\n    return Dir;\n}());\n\nvar bidi_es5_BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: platform_browser[\"b\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = function () { };\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = function () { };\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * OverlayConfig captures the initial configuration used when opening an overlay.\n */\nvar OverlayConfig = (function () {\n    /**\n     * @param {?=} config\n     */\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = (function () {\n    /**\n     * @param {?} _portalHost\n     * @param {?} _pane\n     * @param {?} _config\n     * @param {?} _ngZone\n     */\n    function OverlayRef(_portalHost, _pane, _config, _ngZone) {\n        this._portalHost = _portalHost;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        get: function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalHost.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this.updateSize();\n        this.updateDirection();\n        this.updatePosition();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = function () {\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalHost.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        return detachmentResult;\n    };\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._portalHost.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._detachments.next();\n        this._detachments.complete();\n    };\n    /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = function () {\n        return this._portalHost.hasAttached();\n    };\n    /**\n     * Returns an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = function () {\n        return this._backdropClick.asObservable();\n    };\n    /**\n     * Returns an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = function () {\n        return this._attachments.asObservable();\n    };\n    /**\n     * Returns an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = function () {\n        return this._detachments.asObservable();\n    };\n    /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = function () {\n        return this._config;\n    };\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateDirection = function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        requestAnimationFrame(function () {\n            if (_this._backdropElement) {\n                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n            }\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = function () {\n        if (this._pane.nextSibling) {\n            ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? (value) : value + \"px\";\n}\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    /**\n     * @param {?} origin\n     * @param {?} overlay\n     */\n    function ConnectionPositionPair(origin, overlay) {\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = (function () {\n    /**\n     * @param {?} connectionPair\n     * @param {?} scrollableViewProperties\n     */\n    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /**\n     * @nocollapse\n     */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = (function () {\n    /**\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?} _connectedTo\n     * @param {?} _viewportRuler\n     */\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        get: function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        get: function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        get: function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /**\n     * Performs any cleanup after the element is destroyed.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    ConnectedPositionStrategy.prototype.apply = function () {\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport rect to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {\n        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = function () {\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = document.createElement('div');\n            this._wrapper.classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(this._wrapper, element);\n            this._wrapper.appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = ((element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = (function () {\n    /**\n     * @param {?} _viewportRuler\n     */\n    function OverlayPositionBuilder(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n    }\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = function () {\n        return new GlobalPositionStrategy();\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * The OverlayContainer is the container in which all overlays will load.\n * It should be provided in the root component to ensure it is properly shared.\n */\nvar overlay_es5_OverlayContainer = (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = function () {\n        var /** @type {?} */ container = document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayContainer.ctorParameters = function () { return []; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\n    return parentContainer || new overlay_es5_OverlayContainer();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayContainer]],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     */\n    function CloseScrollStrategy(_scrollDispatcher) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._scrollSubscription = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0, function () {\n                if (_this._overlayRef.hasAttached()) {\n                    _this._overlayRef.detach();\n                }\n                _this.disable();\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    /**\n     * @param {?} _viewportRuler\n     */\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = function () { };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = function () {\n        if (this._isEnabled) {\n            this._isEnabled = false;\n            document.documentElement.style.left = this._previousHTMLStyles.left;\n            document.documentElement.style.top = this._previousHTMLStyles.top;\n            document.documentElement.classList.remove('cdk-global-scrollblock');\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportRect();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?=} _config\n     */\n    function RepositionScrollStrategy(_scrollDispatcher, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle, function () {\n                _this._overlayRef.updatePosition();\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewportRuler\n     */\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = (function () {\n    /**\n     * @param {?} scrollStrategies\n     * @param {?} _overlayContainer\n     * @param {?} _componentFactoryResolver\n     * @param {?} _positionBuilder\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _ngZone\n     */\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates an overlay.\n     * @param {?=} config Config to apply to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalHost = this._createPortalHost(pane);\n        return new overlay_es5_OverlayRef(portalHost, pane, config, this._ngZone);\n    };\n    /**\n     * Returns a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?}\n     */\n    Overlay.prototype.position = function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = function () {\n        var /** @type {?} */ pane = document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = function (pane) {\n        return new portal_es5_DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"z\" /* Injector */], },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * The FullscreenOverlayContainer is the alternative to OverlayContainer\n * that supports correct displaying of overlay elements in Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n * It should be provided in the root component that way:\n * providers: [\n *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}\n * ],\n */\nvar overlay_es5_FullscreenOverlayContainer = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if (((document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if (((document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            ((document)).mozFullScreenElement ||\n            ((document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"y\" /* InjectionToken */]('mat-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_OverlayOrigin = (function () {\n    /**\n     * @param {?} elementRef\n     */\n    function OverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    OverlayOrigin.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    return OverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_ConnectedOverlayDirective = (function () {\n    /**\n     * @param {?} _overlay\n     * @param {?} _renderer\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     * @param {?} _scrollStrategy\n     * @param {?} _dir\n     */\n    function ConnectedOverlayDirective(_overlay, _renderer, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._renderer = _renderer;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._positionSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        this._escapeListener = function () { };\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"s\" /* EventEmitter */]();\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetX\", {\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        get: function () { return this._offsetX; },\n        /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        set: function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetY\", {\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        get: function () { return this._offsetY; },\n        /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        set: function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"hasBackdrop\", {\n        /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        get: function () { return this._hasBackdrop; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOrigin\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.origin; },\n        /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        set: function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedPositions\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.positions; },\n        /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        set: function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOffsetX\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.offsetX; },\n        /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        set: function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOffsetY\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.offsetY; },\n        /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        set: function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedWidth\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.width; },\n        /**\n         * @param {?} _width\n         * @return {?}\n         */\n        set: function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedHeight\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.height; },\n        /**\n         * @param {?} _height\n         * @return {?}\n         */\n        set: function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedMinWidth\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.minWidth; },\n        /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        set: function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedMinHeight\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.minHeight; },\n        /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        set: function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedBackdropClass\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.backdropClass; },\n        /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        set: function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedScrollStrategy\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.scrollStrategy; },\n        /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        set: function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOpen\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.open; },\n        /**\n         * @param {?} _open\n         * @return {?}\n         */\n        set: function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedHasBackdrop\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.hasBackdrop; },\n        /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        set: function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"overlayRef\", {\n        /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        get: function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"dir\", {\n        /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        get: function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._createOverlay = function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._buildConfig = function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._attachOverlay = function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.getConfig().direction = this.dir;\n        this._initEscapeListener();\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._detachOverlay = function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._destroyOverlay = function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._initEscapeListener = function () {\n        var _this = this;\n        this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        });\n    };\n    ConnectedOverlayDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ConnectedOverlayDirective.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"S\" /* Renderer2 */], },\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    ConnectedOverlayDirective.propDecorators = {\n        'origin': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        'positions': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        'offsetX': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        'offsetY': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        'width': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        'height': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        'minWidth': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        'minHeight': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        'backdropClass': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        'scrollStrategy': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        'open': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        'hasBackdrop': [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        '_deprecatedOrigin': [{ type: core[\"A\" /* Input */], args: ['origin',] },],\n        '_deprecatedPositions': [{ type: core[\"A\" /* Input */], args: ['positions',] },],\n        '_deprecatedOffsetX': [{ type: core[\"A\" /* Input */], args: ['offsetX',] },],\n        '_deprecatedOffsetY': [{ type: core[\"A\" /* Input */], args: ['offsetY',] },],\n        '_deprecatedWidth': [{ type: core[\"A\" /* Input */], args: ['width',] },],\n        '_deprecatedHeight': [{ type: core[\"A\" /* Input */], args: ['height',] },],\n        '_deprecatedMinWidth': [{ type: core[\"A\" /* Input */], args: ['minWidth',] },],\n        '_deprecatedMinHeight': [{ type: core[\"A\" /* Input */], args: ['minHeight',] },],\n        '_deprecatedBackdropClass': [{ type: core[\"A\" /* Input */], args: ['backdropClass',] },],\n        '_deprecatedScrollStrategy': [{ type: core[\"A\" /* Input */], args: ['scrollStrategy',] },],\n        '_deprecatedOpen': [{ type: core[\"A\" /* Input */], args: ['open',] },],\n        '_deprecatedHasBackdrop': [{ type: core[\"A\" /* Input */], args: ['hasBackdrop',] },],\n        'backdropClick': [{ type: core[\"L\" /* Output */] },],\n        'positionChange': [{ type: core[\"L\" /* Output */] },],\n        'attach': [{ type: core[\"L\" /* Output */] },],\n        'detach': [{ type: core[\"L\" /* Output */] },],\n    };\n    return ConnectedOverlayDirective;\n}());\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_ConnectedOverlayDirective, overlay_es5_OverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_ConnectedOverlayDirective, overlay_es5_OverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = /** @class */ (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () { return ({\n                bottom: 0,\n                height: 0,\n                left: 0,\n                right: 0,\n                top: 0,\n                width: 0,\n            }); }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () { return ({\n                bottom: event.clientY,\n                height: 0,\n                left: event.clientX,\n                right: event.clientX,\n                top: event.clientY,\n                width: 0,\n            }); };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: this.fakeElement }, { originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = /** @class */ (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        'contextMenuSubject': [{ type: core[\"A\" /* Input */] },],\n        'contextMenu': [{ type: core[\"A\" /* Input */] },],\n        'onContextMenu': [{ type: core[\"v\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(292);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(115);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(294);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(117);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(293);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(116);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(59);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(86);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(707);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(706);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = /** @class */ (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        'subMenu': [{ type: core[\"A\" /* Input */] },],\n        'divider': [{ type: core[\"A\" /* Input */] },],\n        'enabled': [{ type: core[\"A\" /* Input */] },],\n        'passive': [{ type: core[\"A\" /* Input */] },],\n        'visible': [{ type: core[\"A\" /* Input */] },],\n        'execute': [{ type: core[\"L\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = /** @class */ (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"s\" /* EventEmitter */]();\n        this.open = new core[\"s\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_7\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        'autoFocus': [{ type: core[\"A\" /* Input */] },],\n        'useBootstrap4': [{ type: core[\"A\" /* Input */] },],\n        'disabled': [{ type: core[\"A\" /* Input */] },],\n        'close': [{ type: core[\"L\" /* Output */] },],\n        'open': [{ type: core[\"L\" /* Output */] },],\n        'menuItems': [{ type: core[\"o\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        'menuElement': [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_21\" /* crt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(708);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\nvar component_DemoComponent = (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"q\" /* ElementRef */], core[\"z\" /* Injector */], core[\"S\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_6\" /* ViewContainerRef */], platform_browser[\"b\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_41\" /* ppd */](3, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_46\" /* unv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_37\" /* nov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_22\" /* did */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](10, null, [\"\", \"\"])), core[\"_41\" /* ppd */](11, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_22\" /* did */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_46\" /* unv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](4, null, [\"\", \"\"])), core[\"_41\" /* ppd */](5, 3), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](9, null, [\"\", \"\"])), core[\"_41\" /* ppd */](10, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_37\" /* nov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_46\" /* unv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_46\" /* unv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_22\" /* did */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_41\" /* ppd */](7, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_46\" /* unv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_47\" /* vid */](2, [core[\"_39\" /* pid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"D\" /* LOCALE_ID */]]), core[\"_39\" /* pid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_22\" /* did */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_22\" /* did */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_1\" /* TemplateRef */], core[\"q\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_22\" /* did */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_22\" /* did */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_22\" /* did */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_22\" /* did */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_22\" /* did */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_19\" /* ccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(57);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(56);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(50);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/dist/esm/src/draggable-helper.provider.js\nvar draggable_helper_provider = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(113);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/dist/esm/src/drag-and-drop.module.js\nvar drag_and_drop_module = __webpack_require__(166);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(167);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/dist/esm/src/resizable.module.js\nvar resizable_module = __webpack_require__(288);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(168);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(169);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(285);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = /** @class */ (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                    providers: [\n                        contextMenu_service_ContextMenuService,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n/* harmony default export */ var ngx_contextmenu = (ngx_contextmenu_ContextMenuModule);\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 2 modules\nvar datepicker_module = __webpack_require__(289);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(290);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(291);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(114);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_20\" /* cmf */](DemoModule, [], function (_l) { return core[\"_34\" /* mod */]([core[\"_35\" /* mpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_16\" /* CodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"H\" /* NgModuleRef */]]), core[\"_35\" /* mpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"D\" /* LOCALE_ID */], [2, common[\"y\" /* a */]]]), core[\"_35\" /* mpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_35\" /* mpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform]), core[\"_35\" /* mpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */], scrolling_es5_ScrollDispatcher]), core[\"_35\" /* mpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler]), core[\"_35\" /* mpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer]]), core[\"_35\" /* mpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler]), core[\"_35\" /* mpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, core[\"g\" /* ApplicationRef */], core[\"z\" /* Injector */], core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](5120, MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY, MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_35\" /* mpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_35\" /* mpd */](4608, esm5_forms[\"o\" /* i */], esm5_forms[\"o\" /* i */], []), core[\"_35\" /* mpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_35\" /* mpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_35\" /* mpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_35\" /* mpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_35\" /* mpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_35\" /* mpd */](4608, draggable_helper_provider[\"a\" /* DraggableHelper */], draggable_helper_provider[\"a\" /* DraggableHelper */], []), core[\"_35\" /* mpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_35\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_35\" /* mpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_35\" /* mpd */](512, drag_and_drop_module[\"a\" /* DragAndDropModule */], drag_and_drop_module[\"a\" /* DragAndDropModule */], []), core[\"_35\" /* mpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_35\" /* mpd */](512, resizable_module[\"a\" /* ResizableModule */], resizable_module[\"a\" /* ResizableModule */], []), core[\"_35\" /* mpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_35\" /* mpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_35\" /* mpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_35\" /* mpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_35\" /* mpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_35\" /* mpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_35\" /* mpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_35\" /* mpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_35\" /* mpd */](512, esm5_forms[\"m\" /* ba */], esm5_forms[\"m\" /* ba */], []), core[\"_35\" /* mpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_35\" /* mpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_35\" /* mpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_35\" /* mpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_35\" /* mpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* a */]], [2, router[\"m\" /* Router */]]]), core[\"_35\" /* mpd */](512, DemoModule, DemoModule, []), core[\"_35\" /* mpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_35\" /* mpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 711:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(295);\nvar auditTime_1 = __webpack_require__(727);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return auditTime_1.auditTime(duration, scheduler)(this);\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 712:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 716:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar finalize_1 = __webpack_require__(717);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return finalize_1.finalize(callback)(this);\n}\nexports._finally = _finally;\n//# sourceMappingURL=finally.js.map\n\n/***/ }),\n\n/***/ 717:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(11);\nvar Subscription_1 = __webpack_require__(58);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar tap_1 = __webpack_require__(719);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ 719:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(11);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ }),\n\n/***/ 720:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar switchMap_1 = __webpack_require__(721);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return switchMap_1.switchMap(project, resultSelector)(this);\n}\nexports.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n\n/***/ 721:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n\n/***/ 722:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar startWith_1 = __webpack_require__(723);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return startWith_1.startWith.apply(void 0, array)(this);\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n\n/***/ 723:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(123);\nvar ScalarObservable_1 = __webpack_require__(175);\nvar EmptyObservable_1 = __webpack_require__(62);\nvar concat_1 = __webpack_require__(724);\nvar isScheduler_1 = __webpack_require__(171);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n\n/***/ 724:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(171);\nvar of_1 = __webpack_require__(296);\nvar from_1 = __webpack_require__(304);\nvar concatAll_1 = __webpack_require__(307);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 725:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(295);\nvar debounceTime_1 = __webpack_require__(726);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 726:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(295);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 727:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(295);\nvar audit_1 = __webpack_require__(728);\nvar timer_1 = __webpack_require__(729);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 728:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(172);\nvar errorObject_1 = __webpack_require__(118);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 729:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(730);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 730:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(302);\nvar Observable_1 = __webpack_require__(5);\nvar async_1 = __webpack_require__(295);\nvar isScheduler_1 = __webpack_require__(171);\nvar isDate_1 = __webpack_require__(712);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 731:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(295);\nvar delay_1 = __webpack_require__(732);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return delay_1.delay(delay, scheduler)(this);\n}\nexports.delay = delay;\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n\n/***/ 732:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(295);\nvar isDate_1 = __webpack_require__(712);\nvar Subscriber_1 = __webpack_require__(11);\nvar Notification_1 = __webpack_require__(305);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n\n/***/ 733:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(734);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 734:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(172);\nvar isFunction_1 = __webpack_require__(174);\nvar errorObject_1 = __webpack_require__(118);\nvar Subscription_1 = __webpack_require__(58);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1-e37c33b22cbb493d52c3.js","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * Coerces a data-bound value (typically a string) to a number.\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, NINE, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { RxChain, debounceTime, doOperator, filter, first, map } from '@angular/cdk/rxjs';\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { of } from 'rxjs/observable/of';\nimport { CommonModule } from '@angular/common';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar ListKeyManager = (function () {\n    /**\n     * @param {?} _items\n     */\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = RxChain.from(this._letterKeyStream)\n            .call(doOperator, function (keyCode) { return _this._pressedLetters.push(keyCode); })\n            .call(debounceTime, debounceInterval)\n            .call(filter, function () { return _this._pressedLetters.length > 0; })\n            .call(map, function () { return _this._pressedLetters.join(''); })\n            .subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = function (index) {\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        get: function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /**\n         * The active item.\n         * @return {?}\n         */\n        get: function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\nvar ActiveDescendantKeyManager = (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = (function () {\n    /**\n     * @param {?} _platform\n     */\n    function AriaDescriber(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            createMessageElement(message);\n        }\n        if (!isElementDescribedByMessage(hostElement, message)) {\n            addMessageReference(hostElement, message);\n        }\n    };\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (isElementDescribedByMessage(hostElement, message)) {\n            removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            deleteMessagesContainer();\n        }\n    };\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = function () {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        var /** @type {?} */ describedElements = document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * Creates a new element in the visually hidden message container element with the message\n * as its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message) {\n    var /** @type {?} */ messageElement = document.createElement('div');\n    messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n    messageElement.appendChild(/** @type {?} */ ((document.createTextNode(message))));\n    if (!messagesContainer) {\n        createMessagesContainer();\n    } /** @type {?} */\n    ((messagesContainer)).appendChild(messageElement);\n    messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message) {\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n    if (messagesContainer && messageElement) {\n        messagesContainer.removeChild(messageElement);\n    }\n    messageRegistry.delete(message);\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\n    messagesContainer = document.createElement('div');\n    messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n    messagesContainer.setAttribute('aria-hidden', 'true');\n    messagesContainer.style.display = 'none';\n    document.body.appendChild(messagesContainer);\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\n    document.body.removeChild(/** @type {?} */ ((messagesContainer)));\n    messagesContainer = null;\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element) {\n    // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n    var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n        .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n    element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = ((messageRegistry.get(message)));\n    // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\n    addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n    registeredMessage.referenceCount++;\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = ((messageRegistry.get(message)));\n    registeredMessage.referenceCount--;\n    removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element, message) {\n    var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n    return !!messageId && referenceIds.indexOf(messageId) != -1;\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, platform) {\n    return parentDispatcher || new AriaDescriber(platform);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        Platform\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\nvar FocusKeyManager = (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = (function () {\n    /**\n     * @param {?} _platform\n     */\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && ((element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * NOTE: This class currently uses a very simple (naive) approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n * This will be replaced with a more intelligent solution before the library is considered stable.\n */\nvar FocusTrap = (function () {\n    /**\n     * @param {?} _element\n     * @param {?} _platform\n     * @param {?} _checker\n     * @param {?} _ngZone\n     * @param {?=} deferAnchors\n     */\n    function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._platform = _platform;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return this._enabled; },\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = function () {\n        var _this = this;\n        // If we're not on the browser, there can be no focus to trap.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdk-focus-region-\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = function () {\n        var /** @type {?} */ redirectToElement = (this._element.querySelector('[cdk-focus-initial]'));\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Returns whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = function () {\n        var /** @type {?} */ anchor = document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            first.call(this._ngZone.onStable.asObservable()).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = (function () {\n    /**\n     * @param {?} _checker\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    function FocusTrapFactory(_checker, _platform, _ngZone) {\n        this._checker = _checker;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} deferAnchors\n     * @return {?}\n     */\n    FocusTrapFactory.prototype.create = function (element, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * @deprecated\n */\nvar FocusTrapDeprecatedDirective = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusTrapFactory\n     */\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return !this.focusTrap.enabled; },\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        'disabled': [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar FocusTrapDirective = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusTrapFactory\n     */\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\n        /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        get: function () { return this.focusTrap.enabled; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngOnDestroy = function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngAfterContentInit = function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusTrapDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDirective.propDecorators = {\n        'enabled': [{ type: Input, args: ['cdkTrapFocus',] },],\n    };\n    return FocusTrapDirective;\n}());\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = (function () {\n    /**\n     * @param {?} elementToken\n     * @param {?} platform\n     */\n    function LiveAnnouncer(elementToken, platform) {\n        // Only do anything if we're on the browser platform.\n        if (platform.isBrowser) {\n            // We inject the live element as `any` because the constructor signature cannot reference\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n            // causes TypeScript to preserve the constructor signature types.\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = function () {\n        var /** @type {?} */ liveEl = document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: Platform, },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, platform);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        Platform,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = (function () {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _platform\n     */\n    function FocusMonitor(_ngZone, _platform) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = function (element, renderer, checkChildren) {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            renderer: renderer,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerDocumentEvents = function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        // On keydown record the origin and clear any touch event that may be in progress.\n        document.addEventListener('keydown', function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        }, true);\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        document.addEventListener('mousedown', function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        }, true);\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        document.addEventListener('touchstart', function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        }, true);\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        window.addEventListener('focus', function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        });\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            var /** @type {?} */ toggleClass = function (className, shouldSet) {\n                shouldSet ? elementInfo.renderer.addClass(element, className) :\n                    elementInfo.renderer.removeClass(element, className);\n            };\n            toggleClass('cdk-focused', !!origin);\n            toggleClass('cdk-touch-focused', origin === 'touch');\n            toggleClass('cdk-keyboard-focused', origin === 'keyboard');\n            toggleClass('cdk-mouse-focused', origin === 'mouse');\n            toggleClass('cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, renderer,  'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _focusMonitor\n     * @param {?} renderer\n     */\n    function CdkMonitorFocus(_elementRef, _focusMonitor, renderer) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n        { type: Renderer2, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        'cdkFocusChange': [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\nvar A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActiveDescendantKeyManager, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, isFakeMousedownFromScreenReader, FocusKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, FocusTrapDirective, InteractivityChecker, ListKeyManager, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.crt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.did(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.did(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), i0.qud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.eld(2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n        \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.did(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.nov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.did(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, Input, NgModule, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalHostAlreadyDisposedError() {\n    throw Error('This PortalHost has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalHost accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalHostError() {\n    throw Error('Attempting to attach a portal to a null PortalHost');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalHost`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = function (host) {\n        if (host == null) {\n            throwNullPortalHostError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return (host.attach(this));\n    };\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        get: function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = (function (_super) {\n    __extends(ComponentPortal, _super);\n    /**\n     * @param {?} component\n     * @param {?=} viewContainerRef\n     * @param {?=} injector\n     */\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = (function (_super) {\n    __extends(TemplatePortal, _super);\n    /**\n     * @param {?} template\n     * @param {?} viewContainerRef\n     * @param {?=} context\n     */\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalHost`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * Partial implementation of PortalHost that only deals with attaching either a\n * ComponentPortal or a TemplatePortal.\n * @abstract\n */\nvar BasePortalHost = (function () {\n    function BasePortalHost() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalHost.prototype.hasAttached = function () {\n        return !!this._attachedPortal;\n    };\n    /**\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attach = function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalHostAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /**\n     * @abstract\n     * @template T\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attachComponentPortal = function (portal) { };\n    /**\n     * @abstract\n     * @template C\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalHost.prototype.attachTemplatePortal = function (portal) { };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.detach = function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype.dispose = function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalHost.prototype._invokeDisposeFn = function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalHost;\n}());\n\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar DomPortalHost = (function (_super) {\n    __extends(DomPortalHost, _super);\n    /**\n     * @param {?} _hostDomElement\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _defaultInjector\n     */\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachComponentPortal = function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?}\n     */\n    DomPortalHost.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)\n        // To move the view to the specified host element. We just re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalHost.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\n        return (((componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalHost;\n}(BasePortalHost));\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n *\n * Usage:\n * <ng-template portal #greeting>\n *   <p> Hello {{name}} </p>\n * </ng-template>\n */\nvar TemplatePortalDirective = (function (_super) {\n    __extends(TemplatePortalDirective, _super);\n    /**\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     */\n    function TemplatePortalDirective(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    TemplatePortalDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    TemplatePortalDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return TemplatePortalDirective;\n}(TemplatePortal));\n/**\n * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalHost]=\"greeting\"></ng-template>\n */\nvar PortalHostDirective = (function (_super) {\n    __extends(PortalHostDirective, _super);\n    /**\n     * @param {?} _componentFactoryResolver\n     * @param {?} _viewContainerRef\n     */\n    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * The attached portal.\n         */\n        _this._portal = null;\n        return _this;\n    }\n    Object.defineProperty(PortalHostDirective.prototype, \"_deprecatedPortal\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.portal; },\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        set: function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PortalHostDirective.prototype, \"portal\", {\n        /**\n         * Portal associated with the Portal host.\n         * @return {?}\n         */\n        get: function () {\n            return this._portal;\n        },\n        /**\n         * @param {?} portal\n         * @return {?}\n         */\n        set: function (portal) {\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._portal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    PortalHostDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.dispose.call(this);\n        this._portal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal host.\n     * @return {?}\n     */\n    PortalHostDirective.prototype.attachComponentPortal = function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalHost.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._portal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?}\n     */\n    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._portal = portal;\n        return viewRef;\n    };\n    PortalHostDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalHost',\n                    inputs: ['portal: cdkPortalHost']\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PortalHostDirective.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    PortalHostDirective.propDecorators = {\n        '_deprecatedPortal': [{ type: Input, args: ['portalHost',] },],\n    };\n    return PortalHostDirective;\n}(BasePortalHost));\nvar PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [TemplatePortalDirective, PortalHostDirective],\n                    declarations: [TemplatePortalDirective, PortalHostDirective],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    /**\n     * @param {?} _parentInjector\n     * @param {?} _customTokens\n     */\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Portal, ComponentPortal, TemplatePortal, BasePortalHost, DomPortalHost, TemplatePortalDirective, PortalHostDirective, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, Renderer2, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operator/auditTime';\nimport { merge } from 'rxjs/observable/merge';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = (function () {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _platform\n     */\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollableReferences = new Map();\n    }\n    /**\n     * Registers a Scrollable with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event in its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });\n        this.scrollableReferences.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollableReferences.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollableReferences.delete(scrollable);\n        }\n    };\n    /**\n     * Subscribes to an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @param {?=} callback\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs, callback) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        // Scroll events can only happen on the browser, so do nothing if we're not on the browser.\n        if (!this._platform.isBrowser) {\n            return Subscription.EMPTY;\n        }\n        // In the case of a 0ms delay, use an observable without auditTime\n        // since it does add a perceptible delay in processing overhead.\n        var /** @type {?} */ observable = auditTimeInMs > 0 ?\n            auditTime.call(this._scrolled.asObservable(), auditTimeInMs) :\n            this._scrolled.asObservable();\n        this._scrolledCount++;\n        if (!this._globalSubscription) {\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n                return fromEvent(window.document, 'scroll').subscribe(function () { return _this._notify(); });\n            });\n        }\n        // Note that we need to do the subscribing from here, in order to be able to remove\n        // the global event listeners once there are no more subscriptions.\n        var /** @type {?} */ subscription = observable.subscribe(callback);\n        subscription.add(function () {\n            _this._scrolledCount--;\n            if (_this._globalSubscription && !_this.scrollableReferences.size && !_this._scrolledCount) {\n                _this._globalSubscription.unsubscribe();\n                _this._globalSubscription = null;\n            }\n        });\n        return subscription;\n    };\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollableReferences.forEach(function (_subscription, scrollable) {\n            if (_this.scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sends a notification that a scroll event has been fired.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._notify = function () {\n        this._scrolled.next();\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar Scrollable = (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _scroll\n     * @param {?} _ngZone\n     * @param {?} _renderer\n     */\n    function Scrollable(_elementRef, _scroll, _ngZone, _renderer) {\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._renderer = _renderer;\n        this._elementScrolled = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.ngOnInit = function () {\n        var _this = this;\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\n            return _this._renderer.listen(_this.getElementRef().nativeElement, 'scroll', function (event) {\n                _this._elementScrolled.next(event);\n            });\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.ngOnDestroy = function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this._scrollListener();\n            this._scrollListener = null;\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    Scrollable.prototype.elementScrolled = function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    Scrollable.prototype.getElementRef = function () {\n        return this._elementRef;\n    };\n    Scrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Scrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n        { type: Renderer2, },\n    ]; };\n    return Scrollable;\n}());\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = (function () {\n    /**\n     * @param {?} platform\n     * @param {?} ngZone\n     * @param {?} scrollDispatcher\n     */\n    function ViewportRuler(platform, ngZone, scrollDispatcher) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        // Subscribe to scroll and resize events and update the document rectangle on changes.\n        this._invalidateCacheSubscriptions = [\n            scrollDispatcher.scrolled(0, function () { return _this._cacheViewportGeometry(); }),\n            this.change().subscribe(function () { return _this._cacheViewportGeometry(); })\n        ];\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = function () {\n        this._invalidateCacheSubscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });\n    };\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @param {?=} documentRect\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = function (documentRect) {\n        if (documentRect === void 0) { documentRect = this._documentRect; }\n        // Cache the document bounding rect so that we don't recompute it for multiple calls.\n        if (!documentRect) {\n            this._cacheViewportGeometry();\n            documentRect = this._documentRect;\n        }\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\n        var /** @type {?} */ height = window.innerHeight;\n        var /** @type {?} */ width = window.innerWidth;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @param {?=} documentRect\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {\n        if (documentRect === void 0) { documentRect = this._documentRect; }\n        // Cache the document bounding rect so that we don't recompute it for multiple calls.\n        if (!documentRect) {\n            this._cacheViewportGeometry();\n            documentRect = this._documentRect;\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ top = -((documentRect)).top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -((documentRect)).left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? auditTime.call(this._change, throttleTime) : this._change;\n    };\n    /**\n     * Caches the latest client rectangle of the document element.\n     * @return {?}\n     */\n    ViewportRuler.prototype._cacheViewportGeometry = function () {\n        this._documentRect = document.documentElement.getBoundingClientRect();\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n        { type: ScrollDispatcher, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @param {?} scrollDispatcher\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone, scrollDispatcher) {\n    return parentRuler || new ViewportRuler(platform, ngZone, scrollDispatcher);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone, ScrollDispatcher],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\nvar ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [Scrollable],\n                    declarations: [Scrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, Scrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-browser';\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('mat-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = (function () {\n    /**\n     * @param {?=} _document\n     */\n    function Directionality(_document) {\n        this.value = 'ltr';\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var bodyDir = _document.body ? _document.body.dir : null;\n            var htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = (bodyDir || htmlDir || 'ltr');\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDirectionality\n * @param {?} _document\n * @return {?}\n */\nfunction DIRECTIONALITY_PROVIDER_FACTORY(parentDirectionality, _document) {\n    return parentDirectionality || new Directionality(_document);\n}\n/**\n * \\@docs-private\n */\nvar DIRECTIONALITY_PROVIDER = {\n    // If there is already a Directionality available, use that. Otherwise, provide a new one.\n    provide: Directionality,\n    deps: [[new Optional(), new SkipSelf(), Directionality], [new Optional(), DOCUMENT]],\n    useFactory: DIRECTIONALITY_PROVIDER_FACTORY\n};\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Would provide itself in case a component looks for the Directionality service\n */\nvar Dir = (function () {\n    function Dir() {\n        /**\n         * Layout direction of the element.\n         */\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        /**\n         * \\@docs-private\n         * @return {?}\n         */\n        get: function () {\n            return this._dir;\n        },\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        set: function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        get: function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        'change': [{ type: Output, args: ['dirChange',] },],\n        'dir': [{ type: Input, args: ['dir',] },],\n    };\n    return Dir;\n}());\n\nvar BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIRECTIONALITY_PROVIDER_FACTORY, DIRECTIONALITY_PROVIDER, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { DomPortalHost, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { Subject } from 'rxjs/Subject';\nimport { ScrollDispatchModule, ScrollDispatcher, Scrollable, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { Subscription } from 'rxjs/Subscription';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = function () { };\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = function () { };\n    /**\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * OverlayConfig captures the initial configuration used when opening an overlay.\n */\nvar OverlayConfig = (function () {\n    /**\n     * @param {?=} config\n     */\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = (function () {\n    /**\n     * @param {?} _portalHost\n     * @param {?} _pane\n     * @param {?} _config\n     * @param {?} _ngZone\n     */\n    function OverlayRef(_portalHost, _pane, _config, _ngZone) {\n        this._portalHost = _portalHost;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        get: function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalHost.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this.updateSize();\n        this.updateDirection();\n        this.updatePosition();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = function () {\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalHost.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        return detachmentResult;\n    };\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._portalHost.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._detachments.next();\n        this._detachments.complete();\n    };\n    /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = function () {\n        return this._portalHost.hasAttached();\n    };\n    /**\n     * Returns an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = function () {\n        return this._backdropClick.asObservable();\n    };\n    /**\n     * Returns an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = function () {\n        return this._attachments.asObservable();\n    };\n    /**\n     * Returns an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = function () {\n        return this._detachments.asObservable();\n    };\n    /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = function () {\n        return this._config;\n    };\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateDirection = function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        requestAnimationFrame(function () {\n            if (_this._backdropElement) {\n                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n            }\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = function () {\n        if (this._pane.nextSibling) {\n            ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? (value) : value + \"px\";\n}\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    /**\n     * @param {?} origin\n     * @param {?} overlay\n     */\n    function ConnectionPositionPair(origin, overlay) {\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = (function () {\n    /**\n     * @param {?} connectionPair\n     * @param {?} scrollableViewProperties\n     */\n    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /**\n     * @nocollapse\n     */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = (function () {\n    /**\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?} _connectedTo\n     * @param {?} _viewportRuler\n     */\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        get: function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        get: function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        get: function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /**\n     * Performs any cleanup after the element is destroyed.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    ConnectedPositionStrategy.prototype.apply = function () {\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport rect to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {\n        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = function () {\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = document.createElement('div');\n            this._wrapper.classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(this._wrapper, element);\n            this._wrapper.appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = ((element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = (function () {\n    /**\n     * @param {?} _viewportRuler\n     */\n    function OverlayPositionBuilder(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n    }\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = function () {\n        return new GlobalPositionStrategy();\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * The OverlayContainer is the container in which all overlays will load.\n * It should be provided in the root component to ensure it is properly shared.\n */\nvar OverlayContainer = (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = function () {\n        var /** @type {?} */ container = document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayContainer.ctorParameters = function () { return []; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\n    return parentContainer || new OverlayContainer();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [[new Optional(), new SkipSelf(), OverlayContainer]],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     */\n    function CloseScrollStrategy(_scrollDispatcher) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._scrollSubscription = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0, function () {\n                if (_this._overlayRef.hasAttached()) {\n                    _this._overlayRef.detach();\n                }\n                _this.disable();\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    /**\n     * @param {?} _viewportRuler\n     */\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = function () { };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = function () {\n        if (this._isEnabled) {\n            this._isEnabled = false;\n            document.documentElement.style.left = this._previousHTMLStyles.left;\n            document.documentElement.style.top = this._previousHTMLStyles.top;\n            document.documentElement.classList.remove('cdk-global-scrollblock');\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportRect();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?=} _config\n     */\n    function RepositionScrollStrategy(_scrollDispatcher, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle, function () {\n                _this._overlayRef.updatePosition();\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = (function () {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewportRuler\n     */\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = (function () {\n    /**\n     * @param {?} scrollStrategies\n     * @param {?} _overlayContainer\n     * @param {?} _componentFactoryResolver\n     * @param {?} _positionBuilder\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _ngZone\n     */\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates an overlay.\n     * @param {?=} config Config to apply to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalHost = this._createPortalHost(pane);\n        return new OverlayRef(portalHost, pane, config, this._ngZone);\n    };\n    /**\n     * Returns a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?}\n     */\n    Overlay.prototype.position = function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = function () {\n        var /** @type {?} */ pane = document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal host.\n     * @return {?} A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = function (pane) {\n        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * The FullscreenOverlayContainer is the alternative to OverlayContainer\n * that supports correct displaying of overlay elements in Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n * It should be provided in the root component that way:\n * providers: [\n *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}\n * ],\n */\nvar FullscreenOverlayContainer = (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if (((document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if (((document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            ((document)).mozFullScreenElement ||\n            ((document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('mat-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar OverlayOrigin = (function () {\n    /**\n     * @param {?} elementRef\n     */\n    function OverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    OverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return OverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar ConnectedOverlayDirective = (function () {\n    /**\n     * @param {?} _overlay\n     * @param {?} _renderer\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     * @param {?} _scrollStrategy\n     * @param {?} _dir\n     */\n    function ConnectedOverlayDirective(_overlay, _renderer, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._renderer = _renderer;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        this._escapeListener = function () { };\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetX\", {\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        get: function () { return this._offsetX; },\n        /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        set: function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetY\", {\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        get: function () { return this._offsetY; },\n        /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        set: function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"hasBackdrop\", {\n        /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        get: function () { return this._hasBackdrop; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOrigin\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.origin; },\n        /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        set: function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedPositions\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.positions; },\n        /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        set: function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOffsetX\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.offsetX; },\n        /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        set: function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOffsetY\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.offsetY; },\n        /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        set: function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedWidth\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.width; },\n        /**\n         * @param {?} _width\n         * @return {?}\n         */\n        set: function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedHeight\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.height; },\n        /**\n         * @param {?} _height\n         * @return {?}\n         */\n        set: function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedMinWidth\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.minWidth; },\n        /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        set: function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedMinHeight\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.minHeight; },\n        /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        set: function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedBackdropClass\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.backdropClass; },\n        /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        set: function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedScrollStrategy\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.scrollStrategy; },\n        /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        set: function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedOpen\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.open; },\n        /**\n         * @param {?} _open\n         * @return {?}\n         */\n        set: function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"_deprecatedHasBackdrop\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this.hasBackdrop; },\n        /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        set: function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"overlayRef\", {\n        /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        get: function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"dir\", {\n        /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        get: function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._createOverlay = function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._buildConfig = function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._attachOverlay = function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.getConfig().direction = this.dir;\n        this._initEscapeListener();\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._detachOverlay = function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._destroyOverlay = function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    ConnectedOverlayDirective.prototype._initEscapeListener = function () {\n        var _this = this;\n        this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        });\n    };\n    ConnectedOverlayDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    ConnectedOverlayDirective.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: Renderer2, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n    ]; };\n    ConnectedOverlayDirective.propDecorators = {\n        'origin': [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        'positions': [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        'offsetX': [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        'offsetY': [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        'width': [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        'height': [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        'minWidth': [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        'minHeight': [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        'backdropClass': [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        'scrollStrategy': [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        'open': [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        'hasBackdrop': [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        '_deprecatedOrigin': [{ type: Input, args: ['origin',] },],\n        '_deprecatedPositions': [{ type: Input, args: ['positions',] },],\n        '_deprecatedOffsetX': [{ type: Input, args: ['offsetX',] },],\n        '_deprecatedOffsetY': [{ type: Input, args: ['offsetY',] },],\n        '_deprecatedWidth': [{ type: Input, args: ['width',] },],\n        '_deprecatedHeight': [{ type: Input, args: ['height',] },],\n        '_deprecatedMinWidth': [{ type: Input, args: ['minWidth',] },],\n        '_deprecatedMinHeight': [{ type: Input, args: ['minHeight',] },],\n        '_deprecatedBackdropClass': [{ type: Input, args: ['backdropClass',] },],\n        '_deprecatedScrollStrategy': [{ type: Input, args: ['scrollStrategy',] },],\n        '_deprecatedOpen': [{ type: Input, args: ['open',] },],\n        '_deprecatedHasBackdrop': [{ type: Input, args: ['hasBackdrop',] },],\n        'backdropClick': [{ type: Output },],\n        'positionChange': [{ type: Output },],\n        'attach': [{ type: Output },],\n        'detach': [{ type: Output },],\n    };\n    return ConnectedOverlayDirective;\n}());\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PortalModule, ScrollDispatchModule],\n                    exports: [ConnectedOverlayDirective, OverlayOrigin, ScrollDispatchModule],\n                    declarations: [ConnectedOverlayDirective, OverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, FullscreenOverlayContainer, OverlayRef, ConnectedOverlayDirective, OverlayOrigin, ViewportRuler, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, Scrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_CONTAINER_PROVIDER as b, OVERLAY_CONTAINER_PROVIDER_FACTORY as a, MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY as c, MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e, MAT_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d, OverlayPositionBuilder as f };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.crt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.did(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"@angular/platform-browser\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i5 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i7 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i8 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i10 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i12 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i13 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i14 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i16 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i17 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i18 from \"../demo-utils/calendar-header.component\";\nimport * as i19 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i23 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.crt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.nov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.did(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i3.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ppd(3, 3), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.unv(_v, 2, 0, _ck(_v, 3, 0, i0.nov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_3)), i0.did(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ted(10, null, [\"\", \"\"])), i0.ppd(11, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_4)), i0.did(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.nov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.unv(_v, 10, 0, _ck(_v, 11, 0, i0.nov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.did(1, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ted(4, null, [\"\", \"\"])), i0.ppd(5, 3), (_l()(), i0.eld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ted(9, null, [\"\", \"\"])), i0.ppd(10, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.nov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.unv(_v, 4, 0, _ck(_v, 5, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.unv(_v, 9, 0, _ck(_v, 10, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_6)), i0.did(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(3, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ted(6, null, [\"\\n      \", \"\\n    \"])), i0.ppd(7, 3), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.nov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.unv(_v, 6, 0, _ck(_v, 7, 0, i0.nov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i6.View_CalendarMonthViewComponent_0, i6.RenderType_CalendarMonthViewComponent)), i0.did(1, 770048, null, 0, i7.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i9.View_CalendarWeekViewComponent_0, i9.RenderType_CalendarWeekViewComponent)), i0.did(1, 770048, null, 0, i10.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i11.View_CalendarDayViewComponent_0, i11.RenderType_CalendarDayViewComponent)), i0.did(1, 770048, null, 0, i12.CalendarDayViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.vid(2, [i0.pid(0, i13.CalendarDatePipe, [i14.CalendarDateFormatter, i0.LOCALE_ID]), i0.pid(0, i15.CalendarEventTitlePipe, [i16.CalendarEventTitleFormatter]), (_l()(), i0.eld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i17.View_CalendarHeaderComponent_0, i17.RenderType_CalendarHeaderComponent)), i0.did(3, 49152, null, 0, i18.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i19.View_ContextMenuComponent_0, i19.RenderType_ContextMenuComponent)), i0.did(7, 180224, [[\"basicMenu\", 4]], 1, i20.ContextMenuComponent, [i5.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i21.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.did(11, 16384, [[1, 4]], 0, i22.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.did(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_8)), i0.did(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_9)), i0.did(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_10)), i0.did(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.did(1, 49152, null, 0, i23.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ccf(\"mwl-demo-component\", i23.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { _finally } from 'rxjs/operator/finally';\nimport { _catch } from 'rxjs/operator/catch';\nimport { _do } from 'rxjs/operator/do';\nimport { map } from 'rxjs/operator/map';\nimport { filter } from 'rxjs/operator/filter';\nimport { share } from 'rxjs/operator/share';\nimport { first } from 'rxjs/operator/first';\nimport { switchMap } from 'rxjs/operator/switchMap';\nimport { startWith } from 'rxjs/operator/startWith';\nimport { debounceTime } from 'rxjs/operator/debounceTime';\nimport { auditTime } from 'rxjs/operator/auditTime';\nimport { takeUntil } from 'rxjs/operator/takeUntil';\nimport { delay } from 'rxjs/operator/delay';\n\n/**\n * Utility class used to chain RxJS operators.\n *\n * This class is the concrete implementation, but the type used by the user when chaining\n * is StrictRxChain. The strict chain enforces types on the operators to the same level as\n * the prototype-added equivalents.\n */\nvar RxChain = (function () {\n    /**\n     * @param {?} _context\n     */\n    function RxChain(_context) {\n        this._context = _context;\n    }\n    /**\n     * Starts a new chain and specifies the initial `this` value.\n     * @template O\n     * @param {?} context Initial `this` value for the chain.\n     * @return {?}\n     */\n    RxChain.from = function (context) {\n        return new RxChain(context);\n    };\n    /**\n     * Invokes an RxJS operator as a part of the chain.\n     * @param {?} operator Operator to be invoked.\n     * @param {...?} args Arguments to be passed to the operator.\n     * @return {?}\n     */\n    RxChain.prototype.call = function (operator) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this._context = operator.call.apply(operator, [this._context].concat(args));\n        return this;\n    };\n    /**\n     * Subscribes to the result of the chain.\n     * @param {?} fn Callback to be invoked when the result emits a value.\n     * @return {?}\n     */\n    RxChain.prototype.subscribe = function (fn) {\n        return this._context.subscribe(fn);\n    };\n    /**\n     * Returns the result of the chain.\n     * @return {?}\n     */\n    RxChain.prototype.result = function () {\n        return this._context;\n    };\n    return RxChain;\n}());\n\nvar FinallyBrand = (function () {\n    function FinallyBrand() {\n    }\n    return FinallyBrand;\n}());\nvar CatchBrand = (function () {\n    function CatchBrand() {\n    }\n    return CatchBrand;\n}());\nvar DoBrand = (function () {\n    function DoBrand() {\n    }\n    return DoBrand;\n}());\nvar MapBrand = (function () {\n    function MapBrand() {\n    }\n    return MapBrand;\n}());\nvar FilterBrand = (function () {\n    function FilterBrand() {\n    }\n    return FilterBrand;\n}());\nvar ShareBrand = (function () {\n    function ShareBrand() {\n    }\n    return ShareBrand;\n}());\nvar FirstBrand = (function () {\n    function FirstBrand() {\n    }\n    return FirstBrand;\n}());\nvar SwitchMapBrand = (function () {\n    function SwitchMapBrand() {\n    }\n    return SwitchMapBrand;\n}());\nvar StartWithBrand = (function () {\n    function StartWithBrand() {\n    }\n    return StartWithBrand;\n}());\nvar DebounceTimeBrand = (function () {\n    function DebounceTimeBrand() {\n    }\n    return DebounceTimeBrand;\n}());\nvar AuditTimeBrand = (function () {\n    function AuditTimeBrand() {\n    }\n    return AuditTimeBrand;\n}());\nvar TakeUntilBrand = (function () {\n    function TakeUntilBrand() {\n    }\n    return TakeUntilBrand;\n}());\nvar DelayBrand = (function () {\n    function DelayBrand() {\n    }\n    return DelayBrand;\n}());\n// We add `Function` to the type intersection to make this nomically different from\n// `finallyOperatorType` while still being structurally the same. Without this, TypeScript tries to\n// reduce `typeof _finallyOperator & FinallyBrand` to `finallyOperatorType<T>` and then fails\n// because `T` isn't known.\nvar finallyOperator = (_finally);\nvar catchOperator = (_catch);\nvar doOperator = (_do);\nvar map$1 = (map);\nvar filter$1 = (filter);\nvar share$1 = (share);\nvar first$1 = (first);\nvar switchMap$1 = (switchMap);\nvar startWith$1 = (startWith);\nvar debounceTime$1 = (debounceTime);\nvar auditTime$1 = (auditTime);\nvar takeUntil$1 = (takeUntil);\nvar delay$1 = (delay);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxChain, FinallyBrand, CatchBrand, DoBrand, MapBrand, FilterBrand, ShareBrand, FirstBrand, SwitchMapBrand, StartWithBrand, DebounceTimeBrand, AuditTimeBrand, TakeUntilBrand, DelayBrand, finallyOperator, catchOperator, doOperator, map$1 as map, filter$1 as filter, share$1 as share, first$1 as first, switchMap$1 as switchMap, startWith$1 as startWith, debounceTime$1 as debounceTime, auditTime$1 as auditTime, takeUntil$1 as takeUntil, delay$1 as delay };\n//# sourceMappingURL=rxjs.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/rxjs.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && ((Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n * \\@docs-private\n */\nvar Platform = (function () {\n    function Platform() {\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Layout Engines\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n        this.BLINK = this.isBrowser &&\n            (!!(((window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n        // ensure that Webkit runs standalone and is not used as another engine's base.\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Browsers and Platform Types\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\n        // instead of having an unstable check for Gecko.\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n        // Safari browser should also use Webkit as its layout engine.\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /**\n     * @nocollapse\n     */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\nvar PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /**\n     * @nocollapse\n     */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = /** @class */ (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        'menuItems': [{ type: Input },],\n        'item': [{ type: Input },],\n        'event': [{ type: Input },],\n        'parentContextMenu': [{ type: Input },],\n        'overlay': [{ type: Input },],\n        'isLeaf': [{ type: Input },],\n        'execute': [{ type: Output },],\n        'openSubMenu': [{ type: Output },],\n        'closeLeafMenu': [{ type: Output },],\n        'closeAllMenus': [{ type: Output },],\n        'menuElement': [{ type: ViewChild, args: ['menu',] },],\n        'menuItemElements': [{ type: ViewChildren, args: ['li',] },],\n        'onKeyEvent': [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        'keyboardOpenSubMenu': [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        'keyboardMenuItemSelect': [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        'onCloseLeafMenu': [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        'closeMenu': [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = /** @class */ (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () { return ({\n                bottom: 0,\n                height: 0,\n                left: 0,\n                right: 0,\n                top: 0,\n                width: 0,\n            }); }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () { return ({\n                bottom: event.clientY,\n                height: 0,\n                left: event.clientX,\n                right: event.clientX,\n                top: event.clientY,\n                width: 0,\n            }); };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: this.fakeElement }, { originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","import { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = /** @class */ (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        'contextMenuSubject': [{ type: Input },],\n        'contextMenu': [{ type: Input },],\n        'onContextMenu': [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = /** @class */ (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        'subMenu': [{ type: Input },],\n        'divider': [{ type: Input },],\n        'enabled': [{ type: Input },],\n        'passive': [{ type: Input },],\n        'visible': [{ type: Input },],\n        'execute': [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = /** @class */ (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        'autoFocus': [{ type: Input },],\n        'useBootstrap4': [{ type: Input },],\n        'disabled': [{ type: Input },],\n        'close': [{ type: Output },],\n        'open': [{ type: Output },],\n        'menuItems': [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        'menuElement': [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = /** @class */ (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                    providers: [\n                        ContextMenuService,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\nexport default ContextMenuModule;\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/platform\";\nimport * as i8 from \"@angular/cdk/scrolling\";\nimport * as i9 from \"@angular/cdk/overlay\";\nimport * as i10 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i11 from \"@angular/forms\";\nimport * as i12 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i13 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i17 from \"angular-draggable-droppable/dist/esm/src/draggable-helper.provider\";\nimport * as i18 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i19 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i22 from \"angular-draggable-droppable/dist/esm/src/drag-and-drop.module\";\nimport * as i23 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i24 from \"angular-resizable-element/dist/esm/src/resizable.module\";\nimport * as i25 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i26 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i27 from \"../../../src/modules/calendar.module\";\nimport * as i28 from \"@angular/cdk/portal\";\nimport * as i29 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i30 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i31 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i32 from \"../demo-utils/module\";\nimport * as i33 from \"@angular/router\";\nimport * as i34 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i35 from \"./component\";\nvar DemoModuleNgFactory = i0.cmf(i1.DemoModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.a]]), i0.mpd(4608, i7.Platform, i7.Platform, []), i0.mpd(5120, i8.ScrollDispatcher, i8.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i8.ScrollDispatcher], i0.NgZone, i7.Platform]), i0.mpd(5120, i8.ViewportRuler, i8.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i8.ViewportRuler], i7.Platform, i0.NgZone, i8.ScrollDispatcher]), i0.mpd(4608, i9.ScrollStrategyOptions, i9.ScrollStrategyOptions, [i8.ScrollDispatcher, i8.ViewportRuler]), i0.mpd(5120, i9.OverlayContainer, i9.a, [[3, i9.OverlayContainer]]), i0.mpd(4608, i9.f, i9.f, [i8.ViewportRuler]), i0.mpd(4608, i9.Overlay, i9.Overlay, [i9.ScrollStrategyOptions, i9.OverlayContainer, i0.ComponentFactoryResolver, i9.f, i0.ApplicationRef, i0.Injector, i0.NgZone]), i0.mpd(5120, i9.c, i9.d, [i9.Overlay]), i0.mpd(4608, i10.ContextMenuService, i10.ContextMenuService, [i9.Overlay, i9.ScrollStrategyOptions]), i0.mpd(4608, i11.i, i11.i, []), i0.mpd(4608, i12.NgbCalendar, i12.NgbCalendarGregorian, []), i0.mpd(4608, i13.NgbDatepickerI18n, i13.NgbDatepickerI18nDefault, []), i0.mpd(4608, i14.NgbDateParserFormatter, i14.NgbDateISOParserFormatter, []), i0.mpd(4608, i15.NgbDatepickerConfig, i15.NgbDatepickerConfig, []), i0.mpd(4608, i16.NgbTimepickerConfig, i16.NgbTimepickerConfig, []), i0.mpd(4608, i17.DraggableHelper, i17.DraggableHelper, []), i0.mpd(4608, i18.CalendarEventTitleFormatter, i18.CalendarEventTitleFormatter, []), i0.mpd(4608, i19.CalendarDateFormatter, i19.CalendarDateFormatter, []), i0.mpd(4608, i20.CalendarUtils, i20.CalendarUtils, []), i0.mpd(512, i6.CommonModule, i6.CommonModule, []), i0.mpd(512, i21.CalendarCommonModule, i21.CalendarCommonModule, []), i0.mpd(512, i22.DragAndDropModule, i22.DragAndDropModule, []), i0.mpd(512, i23.CalendarMonthModule, i23.CalendarMonthModule, []), i0.mpd(512, i24.ResizableModule, i24.ResizableModule, []), i0.mpd(512, i25.CalendarWeekModule, i25.CalendarWeekModule, []), i0.mpd(512, i26.CalendarDayModule, i26.CalendarDayModule, []), i0.mpd(512, i27.CalendarModule, i27.CalendarModule, []), i0.mpd(512, i28.PortalModule, i28.PortalModule, []), i0.mpd(512, i7.PlatformModule, i7.PlatformModule, []), i0.mpd(512, i8.ScrollDispatchModule, i8.ScrollDispatchModule, []), i0.mpd(512, i9.OverlayModule, i9.OverlayModule, []), i0.mpd(512, i29.ContextMenuModule, i29.ContextMenuModule, []), i0.mpd(512, i11.ba, i11.ba, []), i0.mpd(512, i11.FormsModule, i11.FormsModule, []), i0.mpd(512, i30.NgbDatepickerModule, i30.NgbDatepickerModule, []), i0.mpd(512, i31.NgbTimepickerModule, i31.NgbTimepickerModule, []), i0.mpd(512, i32.DemoUtilsModule, i32.DemoUtilsModule, []), i0.mpd(512, i33.RouterModule, i33.RouterModule, [[2, i33.a], [2, i33.Router]]), i0.mpd(512, i1.DemoModule, i1.DemoModule, []), i0.mpd(256, i34.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.mpd(1024, i33.ROUTES, function () { return [[{ path: \"\", component: i35.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar auditTime_1 = require('../operators/auditTime');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return auditTime_1.auditTime(duration, scheduler)(this);\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/auditTime.js\n// module id = 711\n// module chunks = 1","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 712\n// module chunks = 1","\"use strict\";\nvar finalize_1 = require('../operators/finalize');\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return finalize_1.finalize(callback)(this);\n}\nexports._finally = _finally;\n//# sourceMappingURL=finally.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/finally.js\n// module id = 716\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/finalize.js\n// module id = 717\n// module chunks = 1","\"use strict\";\nvar tap_1 = require('../operators/tap');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/do.js\n// module id = 718\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 719\n// module chunks = 1","\"use strict\";\nvar switchMap_1 = require('../operators/switchMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return switchMap_1.switchMap(project, resultSelector)(this);\n}\nexports.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/switchMap.js\n// module id = 720\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchMap.js\n// module id = 721\n// module chunks = 1","\"use strict\";\nvar startWith_1 = require('../operators/startWith');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return startWith_1.startWith.apply(void 0, array)(this);\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/startWith.js\n// module id = 722\n// module chunks = 1","\"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('../observable/concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/startWith.js\n// module id = 723\n// module chunks = 1","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar of_1 = require('./of');\nvar from_1 = require('./from');\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/concat.js\n// module id = 724\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar debounceTime_1 = require('../operators/debounceTime');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/debounceTime.js\n// module id = 725\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 726\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 727\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 728\n// module chunks = 1","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 729\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 730\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar delay_1 = require('../operators/delay');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return delay_1.delay(delay, scheduler)(this);\n}\nexports.delay = delay;\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/delay.js\n// module id = 731\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/delay.js\n// module id = 732\n// module chunks = 1","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/fromEvent.js\n// module id = 733\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromEventObservable.js\n// module id = 734\n// module chunks = 1"],"sourceRoot":""}