{"version":3,"sources":["webpack:///2-353619af9ae8ae7dfd2f.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/observable/fromEvent.js","webpack:///./node_modules/rxjs/observable/FromEventObservable.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/operators/debounceTime.js","webpack:///./node_modules/rxjs/operators/tap.js"],"names":["webpackJsonp","670","module","__webpack_exports__","__webpack_require__","supportsPassiveEventListeners","supportsPassiveEvents","window","addEventListener","Object","defineProperty","get","SCROLL_DISPATCHER_PROVIDER_FACTORY","parentDispatcher","ngZone","platform","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrolling_es5_ViewportRuler","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalOutletError","throwNoPortalAttachedError","coerceBooleanProperty","value","getMatScrollStrategyAlreadyAttachedError","formatCssUnit","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","overlay_es5_OverlayKeyboardDispatcher","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","getAttribute","match","createMessageElement","message","messageElement","document","createElement","CDK_DESCRIBEDBY_ID_PREFIX","nextId","appendChild","createTextNode","messagesContainer","createMessagesContainer","messageRegistry","set","referenceCount","deleteMessageElement","registeredMessage","removeChild","delete","MESSAGES_CONTAINER_ID","style","display","body","deleteMessagesContainer","removeCdkDescribedByReferenceIds","originalReferenceIds","indexOf","addMessageReference","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","removeMessageReference","removeAttribute","isElementDescribedByMessage","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER_FACTORY","a11y_es5_AriaDescriber","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","ngForOf","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","klass","ngClass","calendar_tooltip_directive","platform_browser","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","DemoModule","calendar_tooltip_directive_ngfactory","hasV8BreakIterator","v8BreakIterator","platform_es5_Platform","Platform","this","isBrowser","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","args","providers","Subject","Observable","of","fromEvent","auditTime","merge","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","prototype","register","scrollable","_this","scrollSubscription","elementScrolled","subscribe","next","deregister","scrollableReference","unsubscribe","scrolled","auditTimeInMs","create","observer","_addGlobalListener","subscription","pipe","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","scrollingContainers","forEach","_subscription","_scrollableContainsElement","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","SCROLL_DISPATCHER_PROVIDER","provide","deps","useFactory","scrolling_es5_CdkScrollable","CdkScrollable","_elementRef","_scroll","_renderer","_elementScrolled","ngOnInit","_scrollListener","listen","ngOnDestroy","asObservable","selector","ViewportRuler","_change","_invalidateCache","change","_updateViewportSize","getViewportSize","_viewportSize","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","_a","documentRect","documentElement","getBoundingClientRect","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","imports","exports","declarations","DIR_DOCUMENT","bidi_es5_Directionality","Directionality","_document","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","v","old","enumerable","configurable","ngAfterContentInit","useExisting","host","[dir]","exportAs","propDecorators","bidi_es5_BidiModule","BidiModule","tslib_es6","Portal","attach","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","_super","ComponentPortal","viewContainerRef","injector","call","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","portal_es5_DomPortalOutlet","DomPortalOutlet","_hostDomElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","destroy","attachView","hostView","detachView","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","index","remove","parentNode","portal_es5_CdkPortal","CdkPortal","portal_es5_CdkPortalOutlet","CdkPortalOutlet","_viewContainerRef","_portal","ref","clear","inputs","_deprecatedPortal","_deprecatedPortalHost","portal_es5_PortalModule","PortalModule","first","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","Subscription","NoopScrollStrategy","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","key","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","CloseScrollStrategy","_scrollDispatcher","_scrollSubscription","overlayRef","_overlayRef","run","BlockScrollStrategy","_viewportRuler","_previousHTMLStyles","_isEnabled","_canBeEnabled","root","_previousScrollPosition","classList","add","html","previousHtmlScrollBehavior","previousBodyScrollBehavior","scroll","contains","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","_config","throttle","scrollThrottle","updatePosition","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","overlay_es5_OverlayRef","OverlayRef","_portalOutlet","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_keydownEvents","attachResult","positionStrategy","_updateStackingOrder","updateSize","updateDirection","onStable","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","isAttached","complete","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","finishDetach_1","setTimeout","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_offsetX","_offsetY","scrollables","_resizeSubscription","EMPTY","_preferredPositions","_onPositionChange","_origin","withFallbackPosition","overlayElement","fallbackPoint","fallbackPosition","originRect","overlayRect","viewportSize","_i","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","_lastConnectedPosition","visibleArea","recalculateLastPosition","lastPosition","withScrollableContainers","position","withDirection","withOffsetX","offset","withOffsetY","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","map","s","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","p","positionChange","overflows","arguments","reduce","currentValue","currentOverflow","Math","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","styles","parentStyles","marginTop","marginLeft","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayKeyboardDispatcher","_attachedOverlays","_keydownEventSubscription","_subscribeToKeydownEvents","splice","bodyKeydownEvents","_selectOverlayFromEvent","find","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","OverlayContainer","_containerElement","getContainerElement","_createContainer","container","OVERLAY_CONTAINER_PROVIDER","nextUniqueId","defaultConfig","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalOutlet","_createPortalOutlet","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_CdkOverlayOrigin","CdkOverlayOrigin","overlay_es5_CdkConnectedOverlay","CdkConnectedOverlay","_overlay","_scrollStrategy","_hasBackdrop","_backdropSubscription","_positionSubscription","_escapeListener","open","_templatePortal","_position","positions","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","strategy","_handlePositionChanges","i","onPositionChange","_initEscapeListener","keyCode","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","debounceTime","tap","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","_pressedLetters","tabOut","withWrap","withTypeAhead","debounceInterval","getLabel","inputString","items","toArray","disabled","toUpperCase","setActiveItem","previousIndex","_activeItem","onKeydown","setNextItemActive","setPreviousItemActive","toLocaleUpperCase","String","fromCharCode","preventDefault","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","AriaDescriber","describe","hostElement","has","removeDescription","childNodes","describedElements","querySelectorAll","ARIA_DESCRIBER_PROVIDER","a11y_es5_InteractivityChecker","FocusKeyManager","focus","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","_createAnchor","focusLastTabbableElement","focusFirstTabbableElement","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","children","tabbableChild","nodeType","Node","ELEMENT_NODE","anchor","isStable","a11y_es5_FocusTrapFactory","FocusTrapFactory","deferCaptureElements","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_focusTrapFactory","focusTrap","enabled","a11y_es5_FocusTrapDirective","FocusTrapDirective","LIVE_ANNOUNCER_ELEMENT_TOKEN","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_windowFocused","_elementInfo","WeakMap","_registerDocumentEvents","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","focusListener","_onFocus","blurListener","_onBlur","removeEventListener","stopMonitoring","elementInfo","_setClasses","focusVia","_setOriginForCurrentEventQueue","_lastTouchTarget","_touchTimeout","clearTimeout","capture","toggleClass","className","shouldSet","addClass","removeClass","_wasCausedByTouch","focusTarget","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","assign","t","n","hasOwnProperty","ContextMenuContentComponent","changeDetector","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","ContextMenuItemDirective","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","concat","attachContextMenu","clientY","clientX","closeAllContextMenus","contextMenuContent","instance","subscriptions","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","getLastAttachedOverlay","slice","newLeaf","subMenuOverlay","isLeafMenu","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","ContextMenuAttachDirective","contextMenuService","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","datepicker_config","timepicker_config","draggable_helper_provider","calendar_common_module","drag_and_drop_module","calendar_month_module","resizable_module","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","711","FromEventObservable_1","FromEventObservable","715","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","toString","isHTMLCollection","isEventTarget","__extends","b","__","constructor","Observable_1","tryCatch_1","isFunction_1","errorObject_1","Subscription_1","eventName","isFunction","setupSubscription","handler","subscriber","len","source_1","source_2","TypeError","source_3","_subscribe","result","tryCatch","errorObject","error","e","716","duration","scheduler","async_1","async","audit_1","audit","timer_1","timer","717","durationSelector","source","lift","AuditOperator","OuterSubscriber_1","subscribeToResult_1","AuditSubscriber","destination","hasValue","_next","throttled","innerSubscription","subscribeToResult","closed","clearThrottle","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete","OuterSubscriber","718","TimerObservable_1","TimerObservable","719","isNumeric_1","isScheduler_1","isDate_1","dueTime","period","isNumeric","Number","isScheduler","isDate","now","initialDelay","dispatch","state","action","schedule","720","721","DebounceTimeOperator","dispatchNext","debouncedNext","Subscriber_1","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","_complete","Subscriber","722","nextOrObserver","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","_error","err"],"mappings":"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","file":"2-353619af9ae8ae7dfd2f.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 670:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(286);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar platform_es5_Platform = (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null) {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar platform_es5_PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(24);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(5);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(299);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(711);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/auditTime.js\nvar auditTime = __webpack_require__(716);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/filter.js\nvar filter = __webpack_require__(171);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(120);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable[\"Observable\"].create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(Object(auditTime[\"auditTime\"])(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : Object(of[\"of\"])();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(Object(filter[\"filter\"])(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_CdkScrollable = (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone, _renderer) {\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._renderer = _renderer;\n        this._elementScrolled = new Subject[\"Subject\"]();\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\n            return _this._renderer.listen(_this.getElementRef().nativeElement, 'scroll', function (event) {\n                _this._elementScrolled.next(event);\n            });\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this._scrollListener();\n            this._scrollListener = null;\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: core[\"S\" /* Renderer2 */], },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"auditTime\"])(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar scrolling_es5_ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_CdkScrollable],\n                    declarations: [scrolling_es5_CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/esm5/platform-browser.js\nvar platform_browser = __webpack_require__(34);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"y\" /* InjectionToken */]('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar bidi_es5_Dir = (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: core[\"L\" /* Output */], args: ['dirChange',] },],\n        \"dir\": [{ type: core[\"A\" /* Input */], args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar bidi_es5_BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: platform_browser[\"b\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(44);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar portal_es5_ComponentPortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar portal_es5_TemplatePortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar portal_es5_DomPortalOutlet = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar portal_es5_CdkPortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    return CdkPortal;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar portal_es5_CdkPortalOutlet = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * The attached portal.\n         */\n        _this._portal = null;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._portal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._portal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._portal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._portal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._portal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: core[\"A\" /* Input */], args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: core[\"A\" /* Input */], args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar portal_es5_PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                    declarations: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/first.js\nvar first = __webpack_require__(300);\nvar first_default = /*#__PURE__*/__webpack_require__.n(first);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(59);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a number.\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Describes a strategy that will be used by an overlay\n * to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached on scroll. */\n    /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this.disable();\n                    if (_this._overlayRef.hasAttached()) {\n                        _this._overlayRef.detach();\n                    }\n                });\n            });\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this.updateSize();\n        this.updateDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(Object(first[\"first\"])()).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /**\n     * Cleans up the overlay from the DOM.\n     */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /**\n     * Checks whether the overlay has been attached.\n     */\n    /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /**\n     * Gets the current config of the overlay.\n     */\n    /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /** Updates the size of the overlay based on the overlay config. */\n    /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        requestAnimationFrame(function () {\n            if (_this._backdropElement) {\n                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n            }\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     *\n     * @returns Resolves when the styles have been applied.\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    function () {\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = document.createElement('div');\n            this._wrapper.classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(this._wrapper, element);\n            this._wrapper.appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = (function () {\n    function OverlayPositionBuilder(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy();\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar overlay_es5_OverlayKeyboardDispatcher = (function () {\n    function OverlayKeyboardDispatcher() {\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = Object(fromEvent[\"fromEvent\"])(document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(Object(filter[\"filter\"])(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return []; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher) {\n    return dispatcher || new overlay_es5_OverlayKeyboardDispatcher();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_es5_OverlayKeyboardDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayKeyboardDispatcher]],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar overlay_es5_OverlayContainer = (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return []; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\n    return parentContainer || new overlay_es5_OverlayContainer();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayContainer]],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new overlay_es5_OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new portal_es5_DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: overlay_es5_OverlayKeyboardDispatcher, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"z\" /* Injector */], },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"y\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkOverlayOrigin = (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkConnectedOverlay = (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, _renderer, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._renderer = _renderer;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._positionSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        this._escapeListener = function () { };\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"s\" /* EventEmitter */]();\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.getConfig().direction = this.dir;\n        this._initEscapeListener();\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._initEscapeListener = /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        });\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"S\" /* Renderer2 */], },\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: core[\"A\" /* Input */], args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: core[\"A\" /* Input */], args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: core[\"A\" /* Input */], args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: core[\"A\" /* Input */], args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: core[\"A\" /* Input */], args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: core[\"A\" /* Input */], args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: core[\"A\" /* Input */], args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: core[\"A\" /* Input */], args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: core[\"A\" /* Input */], args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: core[\"A\" /* Input */], args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: core[\"L\" /* Output */] },],\n        \"positionChange\": [{ type: core[\"L\" /* Output */] },],\n        \"attach\": [{ type: core[\"L\" /* Output */] },],\n        \"detach\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [bidi_es5_BidiModule, portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar overlay_es5_FullscreenOverlayContainer = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"y\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/debounceTime.js\nvar debounceTime = __webpack_require__(721);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/map.js\nvar map = __webpack_require__(173);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/tap.js\nvar tap = __webpack_require__(722);\nvar tap_default = /*#__PURE__*/__webpack_require__.n(tap);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar a11y_es5_ListKeyManager = (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject[\"Subject\"]();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"tap\"])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(debounceTime[\"debounceTime\"])(debounceInterval), Object(filter[\"filter\"])(function () { return _this._pressedLetters.length > 0; }), Object(map[\"map\"])(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar a11y_es5_ActiveDescendantKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the aria-describedby.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = (function () {\n    function AriaDescriber(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            createMessageElement(message);\n        }\n        if (!isElementDescribedByMessage(hostElement, message)) {\n            addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (isElementDescribedByMessage(hostElement, message)) {\n            removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        var /** @type {?} */ describedElements = document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * Creates a new element in the visually hidden message container element with the message\n * as its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message) {\n    var /** @type {?} */ messageElement = document.createElement('div');\n    messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n    messageElement.appendChild(/** @type {?} */ ((document.createTextNode(message))));\n    if (!messagesContainer) {\n        createMessagesContainer();\n    } /** @type {?} */\n    ((messagesContainer)).appendChild(messageElement);\n    messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message) {\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n    if (messagesContainer && messageElement) {\n        messagesContainer.removeChild(messageElement);\n    }\n    messageRegistry.delete(message);\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\n    messagesContainer = document.createElement('div');\n    messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n    messagesContainer.setAttribute('aria-hidden', 'true');\n    messagesContainer.style.display = 'none';\n    document.body.appendChild(messagesContainer);\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\n    document.body.removeChild(/** @type {?} */ ((messagesContainer)));\n    messagesContainer = null;\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element) {\n    // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n    var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n        .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n    element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n    // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\n    addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n    registeredMessage.referenceCount++;\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n    registeredMessage.referenceCount--;\n    removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element, message) {\n    var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n    return !!messageId && referenceIds.indexOf(messageId) != -1;\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, platform) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(platform);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        platform_es5_Platform\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar a11y_es5_FocusKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar a11y_es5_FocusTrap = (function () {\n    function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._platform = _platform;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // If we're not on the browser, there can be no focus to trap.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        if (!this._platform.isBrowser) {\n            return null;\n        }\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(first[\"first\"])()).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = (function () {\n    function FocusTrapFactory(_checker, _platform, _ngZone) {\n        this._checker = _checker;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new a11y_es5_FocusTrap(element, this._platform, this._checker, this._ngZone, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_FocusTrapDirective = (function () {\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDirective.propDecorators = {\n        \"enabled\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocus',] },],\n    };\n    return FocusTrapDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"y\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = (function () {\n    function LiveAnnouncer(elementToken, platform) {\n        // Only do anything if we're on the browser platform.\n        if (platform.isBrowser) {\n            // We inject the live element as `any` because the constructor signature cannot reference\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n            // causes TypeScript to preserve the constructor signature types.\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: platform_es5_Platform, },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, platform);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"K\" /* Optional */](), new core[\"w\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        platform_es5_Platform,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param renderer The renderer to use to apply CSS classes to the element.\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            renderer: renderer,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerDocumentEvents = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        // On keydown record the origin and clear any touch event that may be in progress.\n        document.addEventListener('keydown', function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        }, true);\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        document.addEventListener('mousedown', function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        }, true);\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        document.addEventListener('touchstart', function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n            // Note that we need to cast the event options to `any`, because at the time of writing\n            // (TypeScript 2.5), the built-in types don't support the `addEventListener` options param.\n        }, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        window.addEventListener('focus', function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        });\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            var /** @type {?} */ toggleClass = function (className, shouldSet) {\n                shouldSet ? elementInfo.renderer.addClass(element, className) :\n                    elementInfo.renderer.removeClass(element, className);\n            };\n            toggleClass('cdk-focused', !!origin);\n            toggleClass('cdk-touch-focused', origin === 'touch');\n            toggleClass('cdk-keyboard-focused', origin === 'keyboard');\n            toggleClass('cdk-mouse-focused', origin === 'mouse');\n            toggleClass('cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, renderer,  'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor, renderer) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"s\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n        { type: core[\"S\" /* Renderer2 */], },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar a11y_es5_A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_FocusTrapDirective, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_FocusTrapDirective, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"s\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"P\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"R\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: core[\"A\" /* Input */] },],\n        \"item\": [{ type: core[\"A\" /* Input */] },],\n        \"event\": [{ type: core[\"A\" /* Input */] },],\n        \"parentContextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"overlay\": [{ type: core[\"A\" /* Input */] },],\n        \"isLeaf\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n        \"openSubMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeLeafMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeAllMenus\": [{ type: core[\"L\" /* Output */] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n        \"menuItemElements\": [{ type: core[\"_5\" /* ViewChildren */], args: ['li',] },],\n        \"onKeyEvent\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: core[\"v\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_22\" /* did */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_22\" /* did */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), core[\"_43\" /* qud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_22\" /* did */](7, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_37\" /* nov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_22\" /* did */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"R\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(287);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(85);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"divider\": [{ type: core[\"A\" /* Input */] },],\n        \"enabled\": [{ type: core[\"A\" /* Input */] },],\n        \"passive\": [{ type: core[\"A\" /* Input */] },],\n        \"visible\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: this.fakeElement }, { originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"s\" /* EventEmitter */]();\n        this.open = new core[\"s\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_7\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: core[\"A\" /* Input */] },],\n        \"useBootstrap4\": [{ type: core[\"A\" /* Input */] },],\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n        \"close\": [{ type: core[\"L\" /* Output */] },],\n        \"open\": [{ type: core[\"L\" /* Output */] },],\n        \"menuItems\": [{ type: core[\"o\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: core[\"A\" /* Input */] },],\n        \"contextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"onContextMenu\": [{ type: core[\"v\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(292);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(115);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(294);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(117);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(293);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(116);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(58);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(86);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(707);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(706);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_21\" /* crt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(708);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\nvar component_DemoComponent = (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"q\" /* ElementRef */], core[\"z\" /* Injector */], core[\"S\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_6\" /* ViewContainerRef */], platform_browser[\"b\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_41\" /* ppd */](3, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_46\" /* unv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_37\" /* nov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_22\" /* did */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](10, null, [\"\", \"\"])), core[\"_41\" /* ppd */](11, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_22\" /* did */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_46\" /* unv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](4, null, [\"\", \"\"])), core[\"_41\" /* ppd */](5, 3), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](9, null, [\"\", \"\"])), core[\"_41\" /* ppd */](10, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_37\" /* nov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_46\" /* unv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_46\" /* unv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_22\" /* did */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_41\" /* ppd */](7, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_46\" /* unv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_47\" /* vid */](2, [core[\"_39\" /* pid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"D\" /* LOCALE_ID */]]), core[\"_39\" /* pid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_22\" /* did */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_22\" /* did */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_1\" /* TemplateRef */], core[\"q\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_22\" /* did */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_22\" /* did */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_22\" /* did */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_22\" /* did */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_22\" /* did */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_19\" /* ccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(57);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(56);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(50);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/dist/esm/src/draggable-helper.provider.js\nvar draggable_helper_provider = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(113);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/dist/esm/src/drag-and-drop.module.js\nvar drag_and_drop_module = __webpack_require__(166);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(167);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/dist/esm/src/resizable.module.js\nvar resizable_module = __webpack_require__(288);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(168);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(169);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(285);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                    providers: [\n                        contextMenu_service_ContextMenuService,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n/* harmony default export */ var ngx_contextmenu = (ngx_contextmenu_ContextMenuModule);\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 2 modules\nvar datepicker_module = __webpack_require__(289);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(290);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(291);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(114);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_20\" /* cmf */](DemoModule, [], function (_l) { return core[\"_34\" /* mod */]([core[\"_35\" /* mpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_16\" /* CodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"H\" /* NgModuleRef */]]), core[\"_35\" /* mpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"D\" /* LOCALE_ID */], [2, common[\"y\" /* a */]]]), core[\"_35\" /* mpd */](6144, DIR_DOCUMENT, null, [platform_browser[\"b\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](4608, bidi_es5_Directionality, bidi_es5_Directionality, [[2, DIR_DOCUMENT]]), core[\"_35\" /* mpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_35\" /* mpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform]), core[\"_35\" /* mpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler, core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer]]), core[\"_35\" /* mpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler]), core[\"_35\" /* mpd */](5120, overlay_es5_OverlayKeyboardDispatcher, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayKeyboardDispatcher]]), core[\"_35\" /* mpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayKeyboardDispatcher, core[\"g\" /* ApplicationRef */], core[\"z\" /* Injector */], core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](5120, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_35\" /* mpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_35\" /* mpd */](4608, esm5_forms[\"o\" /* i */], esm5_forms[\"o\" /* i */], []), core[\"_35\" /* mpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_35\" /* mpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_35\" /* mpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_35\" /* mpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_35\" /* mpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_35\" /* mpd */](4608, draggable_helper_provider[\"a\" /* DraggableHelper */], draggable_helper_provider[\"a\" /* DraggableHelper */], []), core[\"_35\" /* mpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_35\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_35\" /* mpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_35\" /* mpd */](512, drag_and_drop_module[\"a\" /* DragAndDropModule */], drag_and_drop_module[\"a\" /* DragAndDropModule */], []), core[\"_35\" /* mpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_35\" /* mpd */](512, resizable_module[\"a\" /* ResizableModule */], resizable_module[\"a\" /* ResizableModule */], []), core[\"_35\" /* mpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_35\" /* mpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_35\" /* mpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_35\" /* mpd */](512, bidi_es5_BidiModule, bidi_es5_BidiModule, []), core[\"_35\" /* mpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_35\" /* mpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_35\" /* mpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_35\" /* mpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_35\" /* mpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_35\" /* mpd */](512, esm5_forms[\"m\" /* ba */], esm5_forms[\"m\" /* ba */], []), core[\"_35\" /* mpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_35\" /* mpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_35\" /* mpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_35\" /* mpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_35\" /* mpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* a */]], [2, router[\"m\" /* Router */]]]), core[\"_35\" /* mpd */](512, DemoModule, DemoModule, []), core[\"_35\" /* mpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_35\" /* mpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 711:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(715);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 715:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(172);\nvar isFunction_1 = __webpack_require__(175);\nvar errorObject_1 = __webpack_require__(118);\nvar Subscription_1 = __webpack_require__(59);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }),\n\n/***/ 716:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(295);\nvar audit_1 = __webpack_require__(717);\nvar timer_1 = __webpack_require__(718);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 717:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(172);\nvar errorObject_1 = __webpack_require__(118);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(719);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 719:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(302);\nvar Observable_1 = __webpack_require__(5);\nvar async_1 = __webpack_require__(295);\nvar isScheduler_1 = __webpack_require__(176);\nvar isDate_1 = __webpack_require__(720);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 720:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 721:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(295);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 722:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(11);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 2-353619af9ae8ae7dfd2f.js","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar Platform = (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null) {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, supportsPassiveEventListeners, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, Renderer2, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { merge } from 'rxjs/observable/merge';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable.create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : of();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar CdkScrollable = (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone, _renderer) {\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._renderer = _renderer;\n        this._elementScrolled = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\n            return _this._renderer.listen(_this.getElementRef().nativeElement, 'scroll', function (event) {\n                _this._elementScrolled.next(event);\n            });\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this._scrollListener();\n            this._scrollListener = null;\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n        { type: Renderer2, },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [CdkScrollable],\n                    declarations: [CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, Input, NgModule, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = (function (_super) {\n    __extends(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = (function (_super) {\n    __extends(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar DomPortalOutlet = (function (_super) {\n    __extends(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar CdkPortal = (function (_super) {\n    __extends(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return CdkPortal;\n}(TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar CdkPortalOutlet = (function (_super) {\n    __extends(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * The attached portal.\n         */\n        _this._portal = null;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._portal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._portal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._portal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._portal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._portal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: Input, args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: Input, args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [CdkPortal, CdkPortalOutlet],\n                    declarations: [CdkPortal, CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a number.\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { Subject } from 'rxjs/Subject';\nimport { first } from 'rxjs/operators/first';\nimport { Subscription } from 'rxjs/Subscription';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Describes a strategy that will be used by an overlay\n * to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached on scroll. */\n    /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this.disable();\n                    if (_this._overlayRef.hasAttached()) {\n                        _this._overlayRef.detach();\n                    }\n                });\n            });\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n        { type: NgZone, },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches the overlay to a portal instance and adds the backdrop.\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this.updateSize();\n        this.updateDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(first()).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /**\n     * Cleans up the overlay from the DOM.\n     */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /**\n     * Checks whether the overlay has been attached.\n     */\n    /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Checks whether the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /**\n     * Gets the current config of the overlay.\n     */\n    /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the current config of the overlay.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /** Updates the size of the overlay based on the overlay config. */\n    /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Updates the size of the overlay based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        requestAnimationFrame(function () {\n            if (_this._backdropElement) {\n                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n            }\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     *\n     * @returns Resolves when the styles have been applied.\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     *\n     * @return {?} Resolves when the styles have been applied.\n     */\n    function () {\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = document.createElement('div');\n            this._wrapper.classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(this._wrapper, element);\n            this._wrapper.appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = (function () {\n    function OverlayPositionBuilder(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy();\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = (function () {\n    function OverlayKeyboardDispatcher() {\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = fromEvent(document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return []; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher) {\n    return dispatcher || new OverlayKeyboardDispatcher();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [[new Optional(), new SkipSelf(), OverlayKeyboardDispatcher]],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return []; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\n    return parentContainer || new OverlayContainer();\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [[new Optional(), new SkipSelf(), OverlayContainer]],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: OverlayKeyboardDispatcher, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, _renderer, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._renderer = _renderer;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        this._escapeListener = function () { };\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.getConfig().direction = this.dir;\n        this._initEscapeListener();\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._escapeListener();\n    };\n    /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._initEscapeListener = /**\n     * Sets the event listener that closes the overlay when pressing Escape.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        });\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: Renderer2, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: Input, args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: Input, args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: Input, args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: Input, args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: Input, args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: Input, args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: Input, args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: Input, args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: Input, args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: Input, args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: Input, args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: Input, args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: Output },],\n        \"positionChange\": [{ type: Output },],\n        \"attach\": [{ type: Output },],\n        \"detach\": [{ type: Output },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [BidiModule, PortalModule, ScrollDispatchModule],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],\n                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as i, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as h, OverlayKeyboardDispatcher as g, OVERLAY_CONTAINER_PROVIDER as b, OVERLAY_CONTAINER_PROVIDER_FACTORY as a, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as c, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d, OverlayPositionBuilder as f };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, NINE, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { first } from 'rxjs/operators/first';\nimport { of } from 'rxjs/observable/of';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar ListKeyManager = (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar ActiveDescendantKeyManager = (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the aria-describedby.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = (function () {\n    function AriaDescriber(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            createMessageElement(message);\n        }\n        if (!isElementDescribedByMessage(hostElement, message)) {\n            addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!this._platform.isBrowser || !message.trim()) {\n            return;\n        }\n        if (isElementDescribedByMessage(hostElement, message)) {\n            removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        var /** @type {?} */ describedElements = document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * Creates a new element in the visually hidden message container element with the message\n * as its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message) {\n    var /** @type {?} */ messageElement = document.createElement('div');\n    messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n    messageElement.appendChild(/** @type {?} */ ((document.createTextNode(message))));\n    if (!messagesContainer) {\n        createMessagesContainer();\n    } /** @type {?} */\n    ((messagesContainer)).appendChild(messageElement);\n    messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message) {\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n    if (messagesContainer && messageElement) {\n        messagesContainer.removeChild(messageElement);\n    }\n    messageRegistry.delete(message);\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\n    messagesContainer = document.createElement('div');\n    messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n    messagesContainer.setAttribute('aria-hidden', 'true');\n    messagesContainer.style.display = 'none';\n    document.body.appendChild(messagesContainer);\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\n    document.body.removeChild(/** @type {?} */ ((messagesContainer)));\n    messagesContainer = null;\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element) {\n    // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n    var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n        .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n    element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n    // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\n    addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n    registeredMessage.referenceCount++;\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element, message) {\n    var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n    registeredMessage.referenceCount--;\n    removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element, message) {\n    var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n    var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n    return !!messageId && referenceIds.indexOf(messageId) != -1;\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, platform) {\n    return parentDispatcher || new AriaDescriber(platform);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        Platform\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar FocusKeyManager = (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar FocusTrap = (function () {\n    function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._platform = _platform;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // If we're not on the browser, there can be no focus to trap.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        if (!this._platform.isBrowser) {\n            return null;\n        }\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(first()).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = (function () {\n    function FocusTrapFactory(_checker, _platform, _ngZone) {\n        this._checker = _checker;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar FocusTrapDeprecatedDirective = (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar FocusTrapDirective = (function () {\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDirective.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n    };\n    return FocusTrapDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = (function () {\n    function LiveAnnouncer(elementToken, platform) {\n        // Only do anything if we're on the browser platform.\n        if (platform.isBrowser) {\n            // We inject the live element as `any` because the constructor signature cannot reference\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n            // causes TypeScript to preserve the constructor signature types.\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: Platform, },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, platform);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        Platform,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\n    }\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param renderer The renderer to use to apply CSS classes to the element.\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    FocusMonitor.prototype.monitor = /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param {?} element The element to monitor\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n     * @return {?} An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            renderer: renderer,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerDocumentEvents = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        // On keydown record the origin and clear any touch event that may be in progress.\n        document.addEventListener('keydown', function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        }, true);\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        document.addEventListener('mousedown', function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        }, true);\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        document.addEventListener('touchstart', function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n            // Note that we need to cast the event options to `any`, because at the time of writing\n            // (TypeScript 2.5), the built-in types don't support the `addEventListener` options param.\n        }, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        window.addEventListener('focus', function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        });\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            var /** @type {?} */ toggleClass = function (className, shouldSet) {\n                shouldSet ? elementInfo.renderer.addClass(element, className) :\n                    elementInfo.renderer.removeClass(element, className);\n            };\n            toggleClass('cdk-focused', !!origin);\n            toggleClass('cdk-touch-focused', origin === 'touch');\n            toggleClass('cdk-keyboard-focused', origin === 'keyboard');\n            toggleClass('cdk-mouse-focused', origin === 'mouse');\n            toggleClass('cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, renderer,  'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor, renderer) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n        { type: Renderer2, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActiveDescendantKeyManager, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, isFakeMousedownFromScreenReader, FocusKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, FocusTrapDirective, InteractivityChecker, ListKeyManager, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.crt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.did(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.did(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), i0.qud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.eld(2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n        \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.did(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.nov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.did(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.crt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.did(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"@angular/platform-browser\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i5 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i7 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i8 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i10 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i12 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i13 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i14 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i16 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i17 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i18 from \"../demo-utils/calendar-header.component\";\nimport * as i19 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i23 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.crt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.nov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.did(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i3.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ppd(3, 3), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.unv(_v, 2, 0, _ck(_v, 3, 0, i0.nov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_3)), i0.did(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ted(10, null, [\"\", \"\"])), i0.ppd(11, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_4)), i0.did(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.nov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.unv(_v, 10, 0, _ck(_v, 11, 0, i0.nov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.did(1, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ted(4, null, [\"\", \"\"])), i0.ppd(5, 3), (_l()(), i0.eld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ted(9, null, [\"\", \"\"])), i0.ppd(10, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.nov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.unv(_v, 4, 0, _ck(_v, 5, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.unv(_v, 9, 0, _ck(_v, 10, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_6)), i0.did(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(3, 16384, null, 0, i4.ContextMenuAttachDirective, [i5.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ted(6, null, [\"\\n      \", \"\\n    \"])), i0.ppd(7, 3), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.nov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.unv(_v, 6, 0, _ck(_v, 7, 0, i0.nov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i6.View_CalendarMonthViewComponent_0, i6.RenderType_CalendarMonthViewComponent)), i0.did(1, 770048, null, 0, i7.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i9.View_CalendarWeekViewComponent_0, i9.RenderType_CalendarWeekViewComponent)), i0.did(1, 770048, null, 0, i10.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i11.View_CalendarDayViewComponent_0, i11.RenderType_CalendarDayViewComponent)), i0.did(1, 770048, null, 0, i12.CalendarDayViewComponent, [i0.ChangeDetectorRef, i8.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.vid(2, [i0.pid(0, i13.CalendarDatePipe, [i14.CalendarDateFormatter, i0.LOCALE_ID]), i0.pid(0, i15.CalendarEventTitlePipe, [i16.CalendarEventTitleFormatter]), (_l()(), i0.eld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i17.View_CalendarHeaderComponent_0, i17.RenderType_CalendarHeaderComponent)), i0.did(3, 49152, null, 0, i18.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i19.View_ContextMenuComponent_0, i19.RenderType_ContextMenuComponent)), i0.did(7, 180224, [[\"basicMenu\", 4]], 1, i20.ContextMenuComponent, [i5.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i21.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.did(11, 16384, [[1, 4]], 0, i22.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.did(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_8)), i0.did(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_9)), i0.did(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_10)), i0.did(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.did(1, 49152, null, 0, i23.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ccf(\"mwl-demo-component\", i23.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output } from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-browser';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar Dir = (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: Output, args: ['dirChange',] },],\n        \"dir\": [{ type: Input, args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE, COMMA };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: Input },],\n        \"item\": [{ type: Input },],\n        \"event\": [{ type: Input },],\n        \"parentContextMenu\": [{ type: Input },],\n        \"overlay\": [{ type: Input },],\n        \"isLeaf\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n        \"openSubMenu\": [{ type: Output },],\n        \"closeLeafMenu\": [{ type: Output },],\n        \"closeAllMenus\": [{ type: Output },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n        \"menuItemElements\": [{ type: ViewChildren, args: ['li',] },],\n        \"onKeyEvent\": [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: Input },],\n        \"divider\": [{ type: Input },],\n        \"enabled\": [{ type: Input },],\n        \"passive\": [{ type: Input },],\n        \"visible\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","import { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: this.fakeElement }, { originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: Input },],\n        \"useBootstrap4\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"close\": [{ type: Output },],\n        \"open\": [{ type: Output },],\n        \"menuItems\": [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: Input },],\n        \"contextMenu\": [{ type: Input },],\n        \"onContextMenu\": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                    providers: [\n                        ContextMenuService,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\nexport default ContextMenuModule;\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n* @fileoverview This file is generated by the Angular template compiler.\n* Do not edit.\n* @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride}\n* tslint:disable\n*/ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/bidi\";\nimport * as i8 from \"@angular/platform-browser\";\nimport * as i9 from \"@angular/cdk/platform\";\nimport * as i10 from \"@angular/cdk/scrolling\";\nimport * as i11 from \"@angular/cdk/overlay\";\nimport * as i12 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i13 from \"@angular/forms\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i17 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i18 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i19 from \"angular-draggable-droppable/dist/esm/src/draggable-helper.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i22 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i23 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i24 from \"angular-draggable-droppable/dist/esm/src/drag-and-drop.module\";\nimport * as i25 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i26 from \"angular-resizable-element/dist/esm/src/resizable.module\";\nimport * as i27 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i28 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i29 from \"../../../src/modules/calendar.module\";\nimport * as i30 from \"@angular/cdk/portal\";\nimport * as i31 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i32 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i33 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i34 from \"../demo-utils/module\";\nimport * as i35 from \"@angular/router\";\nimport * as i36 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i37 from \"./component\";\nvar DemoModuleNgFactory = i0.cmf(i1.DemoModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.a]]), i0.mpd(6144, i7.DIR_DOCUMENT, null, [i8.DOCUMENT]), i0.mpd(4608, i7.Directionality, i7.Directionality, [[2, i7.DIR_DOCUMENT]]), i0.mpd(4608, i9.Platform, i9.Platform, []), i0.mpd(5120, i10.ScrollDispatcher, i10.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i10.ScrollDispatcher], i0.NgZone, i9.Platform]), i0.mpd(5120, i10.ViewportRuler, i10.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i10.ViewportRuler], i9.Platform, i0.NgZone]), i0.mpd(4608, i11.ScrollStrategyOptions, i11.ScrollStrategyOptions, [i10.ScrollDispatcher, i10.ViewportRuler, i0.NgZone]), i0.mpd(5120, i11.OverlayContainer, i11.a, [[3, i11.OverlayContainer]]), i0.mpd(4608, i11.f, i11.f, [i10.ViewportRuler]), i0.mpd(5120, i11.g, i11.h, [[3, i11.g]]), i0.mpd(4608, i11.Overlay, i11.Overlay, [i11.ScrollStrategyOptions, i11.OverlayContainer, i0.ComponentFactoryResolver, i11.f, i11.g, i0.ApplicationRef, i0.Injector, i0.NgZone]), i0.mpd(5120, i11.c, i11.d, [i11.Overlay]), i0.mpd(4608, i12.ContextMenuService, i12.ContextMenuService, [i11.Overlay, i11.ScrollStrategyOptions]), i0.mpd(4608, i13.i, i13.i, []), i0.mpd(4608, i14.NgbCalendar, i14.NgbCalendarGregorian, []), i0.mpd(4608, i15.NgbDatepickerI18n, i15.NgbDatepickerI18nDefault, []), i0.mpd(4608, i16.NgbDateParserFormatter, i16.NgbDateISOParserFormatter, []), i0.mpd(4608, i17.NgbDatepickerConfig, i17.NgbDatepickerConfig, []), i0.mpd(4608, i18.NgbTimepickerConfig, i18.NgbTimepickerConfig, []), i0.mpd(4608, i19.DraggableHelper, i19.DraggableHelper, []), i0.mpd(4608, i20.CalendarEventTitleFormatter, i20.CalendarEventTitleFormatter, []), i0.mpd(4608, i21.CalendarDateFormatter, i21.CalendarDateFormatter, []), i0.mpd(4608, i22.CalendarUtils, i22.CalendarUtils, []), i0.mpd(512, i6.CommonModule, i6.CommonModule, []), i0.mpd(512, i23.CalendarCommonModule, i23.CalendarCommonModule, []), i0.mpd(512, i24.DragAndDropModule, i24.DragAndDropModule, []), i0.mpd(512, i25.CalendarMonthModule, i25.CalendarMonthModule, []), i0.mpd(512, i26.ResizableModule, i26.ResizableModule, []), i0.mpd(512, i27.CalendarWeekModule, i27.CalendarWeekModule, []), i0.mpd(512, i28.CalendarDayModule, i28.CalendarDayModule, []), i0.mpd(512, i29.CalendarModule, i29.CalendarModule, []), i0.mpd(512, i7.BidiModule, i7.BidiModule, []), i0.mpd(512, i30.PortalModule, i30.PortalModule, []), i0.mpd(512, i9.PlatformModule, i9.PlatformModule, []), i0.mpd(512, i10.ScrollDispatchModule, i10.ScrollDispatchModule, []), i0.mpd(512, i11.OverlayModule, i11.OverlayModule, []), i0.mpd(512, i31.ContextMenuModule, i31.ContextMenuModule, []), i0.mpd(512, i13.ba, i13.ba, []), i0.mpd(512, i13.FormsModule, i13.FormsModule, []), i0.mpd(512, i32.NgbDatepickerModule, i32.NgbDatepickerModule, []), i0.mpd(512, i33.NgbTimepickerModule, i33.NgbTimepickerModule, []), i0.mpd(512, i34.DemoUtilsModule, i34.DemoUtilsModule, []), i0.mpd(512, i35.RouterModule, i35.RouterModule, [[2, i35.a], [2, i35.Router]]), i0.mpd(512, i1.DemoModule, i1.DemoModule, []), i0.mpd(256, i36.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.mpd(1024, i35.ROUTES, function () { return [[{ path: \"\", component: i37.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/fromEvent.js\n// module id = 711\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromEventObservable.js\n// module id = 715\n// module chunks = 2","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 716\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 717\n// module chunks = 2","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 718\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 719\n// module chunks = 2","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 720\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 721\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 722\n// module chunks = 2"],"sourceRoot":""}