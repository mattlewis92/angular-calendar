{"version":3,"sources":["webpack:///2-4aeb54ad63fc47b95064.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/observable/fromEvent.js","webpack:///./node_modules/rxjs/observable/FromEventObservable.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/operators/debounceTime.js","webpack:///./node_modules/rxjs/operators/tap.js"],"names":["webpackJsonp","643","module","__webpack_exports__","__webpack_require__","supportsPassiveEventListeners","supportsPassiveEvents","window","addEventListener","Object","defineProperty","get","SCROLL_DISPATCHER_PROVIDER_FACTORY","parentDispatcher","ngZone","platform","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrolling_es5_ViewportRuler","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalOutletError","throwNoPortalAttachedError","coerceBooleanProperty","value","getMatScrollStrategyAlreadyAttachedError","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","formatCssUnit","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","_document","overlay_es5_OverlayKeyboardDispatcher","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","getAttribute","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","match","ARIA_DESCRIBER_PROVIDER_FACTORY","a11y_es5_AriaDescriber","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","ngForOf","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","klass","ngClass","calendar_tooltip_directive","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","DemoModule","calendar_tooltip_directive_ngfactory","hasV8BreakIterator","v8BreakIterator","platform_es5_Platform","Platform","this","isBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","args","providers","Subject","Observable","of","fromEvent","auditTime","merge","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","prototype","register","scrollable","_this","scrollSubscription","elementScrolled","subscribe","next","set","deregister","scrollableReference","unsubscribe","delete","scrolled","auditTimeInMs","create","observer","_addGlobalListener","subscription","pipe","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","indexOf","scrollingContainers","forEach","_subscription","_scrollableContainsElement","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","SCROLL_DISPATCHER_PROVIDER","provide","deps","useFactory","scrolling_es5_CdkScrollable","CdkScrollable","_elementRef","_scroll","_elementScrolled","_scrollListener","ngOnInit","ngOnDestroy","removeEventListener","asObservable","selector","ViewportRuler","_change","_invalidateCache","change","_updateViewportSize","getViewportSize","_viewportSize","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","_a","documentRect","documentElement","getBoundingClientRect","body","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","imports","exports","declarations","DIR_DOCUMENT","bidi_es5_Directionality","Directionality","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","v","old","enumerable","configurable","ngAfterContentInit","useExisting","host","[dir]","exportAs","propDecorators","bidi_es5_BidiModule","BidiModule","tslib_es6","Portal","attach","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","_super","ComponentPortal","viewContainerRef","injector","call","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","portal_es5_DomPortalOutlet","DomPortalOutlet","_hostDomElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","destroy","attachView","hostView","detachView","appendChild","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","index","remove","parentNode","removeChild","portal_es5_CdkPortal","CdkPortal","portal_es5_CdkPortalOutlet","CdkPortalOutlet","_viewContainerRef","ref","clear","inputs","_deprecatedPortal","_deprecatedPortalHost","portal_es5_PortalModule","PortalModule","take","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","Subscription","ESCAPE","NoopScrollStrategy","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","key","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","CloseScrollStrategy","_scrollDispatcher","_scrollSubscription","overlayRef","_overlayRef","run","BlockScrollStrategy","_viewportRuler","_previousHTMLStyles","_isEnabled","_canBeEnabled","root","_previousScrollPosition","style","classList","add","html","previousHtmlScrollBehavior","previousBodyScrollBehavior","scroll","contains","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","_config","throttle","scrollThrottle","updatePosition","autoClose","overlayRect","overlayElement","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","overlay_es5_OverlayRef","OverlayRef","_portalOutlet","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_keydownEvents","attachResult","positionStrategy","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","isAttached","complete","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","updateSize","sizeConfig","setDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","createElement","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","finishDetach_1","setTimeout","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_offsetX","_offsetY","scrollables","_resizeSubscription","EMPTY","_preferredPositions","_applied","_positionLocked","_onPositionChange","_origin","withFallbackPosition","_lastConnectedPosition","recalculateLastPosition","fallbackPoint","fallbackPosition","originRect","viewportSize","_i","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","visibleArea","lastPosition","withScrollableContainers","position","withDirection","withOffsetX","offset","withOffsetY","withLockedPosition","isLocked","withPositions","positions","slice","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","map","s","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","p","positionChange","overflows","arguments","reduce","currentValue","currentOverflow","Math","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","styles","parentStyles","marginTop","marginLeft","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayKeyboardDispatcher","_attachedOverlays","_unsubscribeFromKeydownEvents","_keydownEventSubscription","_subscribeToKeydownEvents","splice","bodyKeydownEvents","_selectOverlayFromEvent","find","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","OverlayContainer","_containerElement","getContainerElement","_createContainer","container","OVERLAY_CONTAINER_PROVIDER","nextUniqueId","defaultConfig","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalOutlet","_createPortalOutlet","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_CdkOverlayOrigin","CdkOverlayOrigin","overlay_es5_CdkConnectedOverlay","CdkConnectedOverlay","_overlay","_scrollStrategy","_hasBackdrop","_backdropSubscription","_positionSubscription","open","_escapeListener","keyCode","_detachOverlay","_templatePortal","_position","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","_attachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","strategy","_handlePositionChanges","i","onPositionChange","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","debounceTime","tap","a11y_es5_InteractivityChecker","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","_createAnchor","focusLastTabbableElement","focusFirstTabbableElement","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","querySelectorAll","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","focus","children","childNodes","tabbableChild","nodeType","Node","ELEMENT_NODE","anchor","isStable","a11y_es5_FocusTrapFactory","FocusTrapFactory","deferCaptureElements","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_focusTrapFactory","focusTrap","enabled","disabled","a11y_es5_CdkTrapFocus","CdkTrapFocus","_previouslyFocusedElement","_autoCapture","autoCapture","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","_pressedLetters","tabOut","withWrap","withTypeAhead","debounceInterval","getLabel","inputString","items","toArray","toUpperCase","setActiveItem","previousIndex","_activeItem","onKeydown","setNextItemActive","setPreviousItemActive","toLocaleUpperCase","String","fromCharCode","preventDefault","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","nextId","messageRegistry","messagesContainer","AriaDescriber","describe","hostElement","message","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_removeMessageReference","registeredMessage","referenceCount","_deleteMessageElement","_deleteMessagesContainer","describedElements","_removeCdkDescribedByReferenceIds","removeAttribute","messageElement","CDK_DESCRIBEDBY_ID_PREFIX","createTextNode","_createMessagesContainer","display","originalReferenceIds","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER","LIVE_ANNOUNCER_ELEMENT_TOKEN","FocusKeyManager","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_windowFocused","_elementInfo","WeakMap","_unregisterGlobalListeners","_monitoredElementCount","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","_setClasses","_decrementMonitoredElementCount","focusVia","_setOriginForCurrentEventQueue","_registerGlobalListeners","documentKeydownListener","_lastTouchTarget","documentMousedownListener","documentTouchstartListener","_touchTimeout","clearTimeout","windowFocusListener","capture","_toggleClass","className","shouldSet","_wasCausedByTouch","focusTarget","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","assign","t","n","hasOwnProperty","ContextMenuContentComponent","changeDetector","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","ContextMenuItemDirective","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","concat","attachContextMenu","clientY","clientX","closeAllContextMenus","contextMenuContent","instance","subscriptions","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","getLastAttachedOverlay","newLeaf","subMenuOverlay","isLeafMenu","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","ContextMenuAttachDirective","contextMenuService","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","ngb_date_adapter","datepicker_config","timepicker_config","angular_draggable_droppable","calendar_common_module","calendar_month_module","angular_resizable_element","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","686","FromEventObservable_1","FromEventObservable","690","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","toString","isHTMLCollection","isEventTarget","__extends","b","__","constructor","Observable_1","tryCatch_1","isFunction_1","errorObject_1","Subscription_1","eventName","isFunction","setupSubscription","handler","subscriber","len","source_1","source_2","TypeError","source_3","_subscribe","result","tryCatch","errorObject","error","e","691","duration","scheduler","async_1","async","audit_1","audit","timer_1","timer","692","durationSelector","source","lift","AuditOperator","OuterSubscriber_1","subscribeToResult_1","AuditSubscriber","destination","hasValue","_next","throttled","innerSubscription","subscribeToResult","closed","clearThrottle","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete","OuterSubscriber","693","TimerObservable_1","TimerObservable","694","isNumeric_1","isScheduler_1","isDate_1","dueTime","period","isNumeric","Number","isScheduler","isDate","now","initialDelay","dispatch","state","action","schedule","695","696","DebounceTimeOperator","dispatchNext","debouncedNext","Subscriber_1","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","_complete","Subscriber","697","nextOrObserver","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","_error","err"],"mappings":"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","file":"2-4aeb54ad63fc47b95064.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 643:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = /** @class */ (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(275);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar platform_es5_Platform = (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar platform_es5_PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(28);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(11);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(284);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(686);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/auditTime.js\nvar auditTime = __webpack_require__(691);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/filter.js\nvar filter = __webpack_require__(84);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(123);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable[\"Observable\"].create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(Object(auditTime[\"auditTime\"])(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : Object(of[\"of\"])();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(Object(filter[\"filter\"])(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_CdkScrollable = (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject[\"Subject\"]();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"auditTime\"])(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar scrolling_es5_ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_CdkScrollable],\n                    declarations: [scrolling_es5_CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"y\" /* InjectionToken */]('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar bidi_es5_Dir = (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: core[\"L\" /* Output */], args: ['dirChange',] },],\n        \"dir\": [{ type: core[\"A\" /* Input */], args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar bidi_es5_BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: common[\"d\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(44);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar portal_es5_ComponentPortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar portal_es5_TemplatePortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar portal_es5_DomPortalOutlet = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar portal_es5_CdkPortal = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    return CdkPortal;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar portal_es5_CdkPortalOutlet = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: core[\"A\" /* Input */], args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: core[\"A\" /* Input */], args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar portal_es5_PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                    declarations: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/take.js\nvar take = __webpack_require__(121);\nvar take_default = /*#__PURE__*/__webpack_require__.n(take);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(58);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached on scroll. */\n    /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this.disable();\n                    if (_this._overlayRef.hasAttached()) {\n                        _this._overlayRef.detach();\n                    }\n                });\n            });\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        this._ngZone.runOutsideAngular(function () {\n            requestAnimationFrame(function () {\n                if (_this._backdropElement) {\n                    _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n                }\n            });\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar overlay_es5_OverlayKeyboardDispatcher = (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = Object(fromEvent[\"fromEvent\"])(this._document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(Object(filter[\"filter\"])(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new overlay_es5_OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_es5_OverlayKeyboardDispatcher,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar overlay_es5_OverlayContainer = (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new overlay_es5_OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayContainer],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */] // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new overlay_es5_OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new portal_es5_DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: overlay_es5_OverlayKeyboardDispatcher, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"z\" /* Injector */], },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"y\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkOverlayOrigin = (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkConnectedOverlay = (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir, _document) {\n        var _this = this;\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._document = _document;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._positionSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event listener that will close the overlay when the user presses escape.\n         */\n        this._escapeListener = function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        };\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        this._document.addEventListener('keydown', this._escapeListener);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._document.removeEventListener('keydown', this._escapeListener);\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._document.removeEventListener('keydown', this._escapeListener);\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"K\" /* Optional */] },] },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: core[\"A\" /* Input */], args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: core[\"A\" /* Input */], args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: core[\"A\" /* Input */], args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: core[\"A\" /* Input */], args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: core[\"A\" /* Input */], args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: core[\"A\" /* Input */], args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: core[\"A\" /* Input */], args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: core[\"A\" /* Input */], args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: core[\"A\" /* Input */], args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: core[\"A\" /* Input */], args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: core[\"L\" /* Output */] },],\n        \"positionChange\": [{ type: core[\"L\" /* Output */] },],\n        \"attach\": [{ type: core[\"L\" /* Output */] },],\n        \"detach\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [bidi_es5_BidiModule, portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar overlay_es5_FullscreenOverlayContainer = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"y\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/debounceTime.js\nvar debounceTime = __webpack_require__(696);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/map.js\nvar map = __webpack_require__(85);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/tap.js\nvar tap = __webpack_require__(697);\nvar tap_default = /*#__PURE__*/__webpack_require__.n(tap);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar a11y_es5_FocusTrap = (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new a11y_es5_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_CdkTrapFocus = (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar a11y_es5_ListKeyManager = (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject[\"Subject\"]();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"tap\"])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(debounceTime[\"debounceTime\"])(debounceInterval), Object(filter[\"filter\"])(function () { return _this._pressedLetters.length > 0; }), Object(map[\"map\"])(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar a11y_es5_ActiveDescendantKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar a11y_es5_FocusKeyManager = (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"y\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"K\" /* Optional */](), new core[\"w\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        common[\"d\" /* DOCUMENT */],\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof core[\"S\" /* Renderer2 */])) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"s\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar a11y_es5_A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"s\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"P\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"R\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: core[\"A\" /* Input */] },],\n        \"item\": [{ type: core[\"A\" /* Input */] },],\n        \"event\": [{ type: core[\"A\" /* Input */] },],\n        \"parentContextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"overlay\": [{ type: core[\"A\" /* Input */] },],\n        \"isLeaf\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n        \"openSubMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeLeafMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeAllMenus\": [{ type: core[\"L\" /* Output */] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n        \"menuItemElements\": [{ type: core[\"_5\" /* ViewChildren */], args: ['li',] },],\n        \"onKeyEvent\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: core[\"v\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_18\" /* and */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_22\" /* did */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_40\" /* pod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_22\" /* did */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_22\" /* did */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), core[\"_43\" /* qud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_22\" /* did */](7, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_37\" /* nov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_37\" /* nov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_37\" /* nov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_37\" /* nov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_22\" /* did */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"R\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(276);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(87);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"divider\": [{ type: core[\"A\" /* Input */] },],\n        \"enabled\": [{ type: core[\"A\" /* Input */] },],\n        \"passive\": [{ type: core[\"A\" /* Input */] },],\n        \"visible\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"s\" /* EventEmitter */]();\n        this.open = new core[\"s\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_7\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: core[\"A\" /* Input */] },],\n        \"useBootstrap4\": [{ type: core[\"A\" /* Input */] },],\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n        \"close\": [{ type: core[\"L\" /* Output */] },],\n        \"open\": [{ type: core[\"L\" /* Output */] },],\n        \"menuItems\": [{ type: core[\"o\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: core[\"A\" /* Input */] },],\n        \"contextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"onContextMenu\": [{ type: core[\"v\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(280);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(117);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(282);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(119);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(281);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(118);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(59);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(33);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(88);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(682);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(681);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_21\" /* crt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_47\" /* vid */](0, [core[\"_43\" /* qud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_19\" /* ccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(683);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\nvar component_DemoComponent = /** @class */ (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_21\" /* crt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_37\" /* nov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"q\" /* ElementRef */], core[\"z\" /* Injector */], core[\"S\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_6\" /* ViewContainerRef */], common[\"d\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_41\" /* ppd */](3, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_46\" /* unv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_37\" /* nov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_22\" /* did */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](10, null, [\"\", \"\"])), core[\"_41\" /* ppd */](11, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_22\" /* did */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_46\" /* unv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](4, null, [\"\", \"\"])), core[\"_41\" /* ppd */](5, 3), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* eld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](9, null, [\"\", \"\"])), core[\"_41\" /* ppd */](10, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_37\" /* nov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_46\" /* unv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_46\" /* unv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_37\" /* nov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_22\" /* did */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* eld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_37\" /* nov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* did */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* did */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* eld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_41\" /* ppd */](7, 3), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_46\" /* unv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_37\" /* nov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_22\" /* did */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_37\" /* nov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_47\" /* vid */](2, [core[\"_39\" /* pid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"D\" /* LOCALE_ID */]]), core[\"_39\" /* pid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_23\" /* eld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_22\" /* did */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* did */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* qud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_22\" /* did */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_1\" /* TemplateRef */], core[\"q\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* and */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* eld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_22\" /* did */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_22\" /* did */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_22\" /* did */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* and */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_22\" /* did */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_47\" /* vid */](0, [(_l()(), core[\"_23\" /* eld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_22\" /* did */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_19\" /* ccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(57);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter.js\nvar ngb_date_adapter = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(56);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(50);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/esm5/angular-draggable-droppable.js\nvar angular_draggable_droppable = __webpack_require__(27);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(115);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(166);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/esm5/angular-resizable-element.js\nvar angular_resizable_element = __webpack_require__(114);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(167);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(168);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(274);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                contextMenu_service_ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 3 modules\nvar datepicker_module = __webpack_require__(277);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(278);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(279);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(116);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_20\" /* cmf */](DemoModule, [], function (_l) { return core[\"_34\" /* mod */]([core[\"_35\" /* mpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_16\" /* CodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"H\" /* NgModuleRef */]]), core[\"_35\" /* mpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"D\" /* LOCALE_ID */], [2, common[\"y\" /* a */]]]), core[\"_35\" /* mpd */](6144, DIR_DOCUMENT, null, [common[\"d\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](4608, bidi_es5_Directionality, bidi_es5_Directionality, [[2, DIR_DOCUMENT]]), core[\"_35\" /* mpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_35\" /* mpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform]), core[\"_35\" /* mpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler, core[\"J\" /* NgZone */]]), core[\"_35\" /* mpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer], common[\"d\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler, common[\"d\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](5120, overlay_es5_OverlayKeyboardDispatcher, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayKeyboardDispatcher], common[\"d\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayKeyboardDispatcher, core[\"g\" /* ApplicationRef */], core[\"z\" /* Injector */], core[\"J\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_35\" /* mpd */](5120, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_35\" /* mpd */](4608, esm5_forms[\"o\" /* i */], esm5_forms[\"o\" /* i */], []), core[\"_35\" /* mpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_35\" /* mpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_35\" /* mpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_35\" /* mpd */](4608, ngb_date_adapter[\"a\" /* NgbDateAdapter */], ngb_date_adapter[\"b\" /* NgbDateStructAdapter */], []), core[\"_35\" /* mpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_35\" /* mpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_35\" /* mpd */](4608, angular_draggable_droppable[\"b\" /* DraggableHelper */], angular_draggable_droppable[\"b\" /* DraggableHelper */], []), core[\"_35\" /* mpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_35\" /* mpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_35\" /* mpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_35\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_35\" /* mpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_35\" /* mpd */](512, angular_draggable_droppable[\"a\" /* DragAndDropModule */], angular_draggable_droppable[\"a\" /* DragAndDropModule */], []), core[\"_35\" /* mpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_35\" /* mpd */](512, angular_resizable_element[\"b\" /* ResizableModule */], angular_resizable_element[\"b\" /* ResizableModule */], []), core[\"_35\" /* mpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_35\" /* mpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_35\" /* mpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_35\" /* mpd */](512, bidi_es5_BidiModule, bidi_es5_BidiModule, []), core[\"_35\" /* mpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_35\" /* mpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_35\" /* mpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_35\" /* mpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_35\" /* mpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_35\" /* mpd */](512, esm5_forms[\"m\" /* ba */], esm5_forms[\"m\" /* ba */], []), core[\"_35\" /* mpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_35\" /* mpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_35\" /* mpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_35\" /* mpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_35\" /* mpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* a */]], [2, router[\"m\" /* Router */]]]), core[\"_35\" /* mpd */](512, DemoModule, DemoModule, []), core[\"_35\" /* mpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_35\" /* mpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 686:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(690);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 690:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(11);\nvar tryCatch_1 = __webpack_require__(170);\nvar isFunction_1 = __webpack_require__(172);\nvar errorObject_1 = __webpack_require__(120);\nvar Subscription_1 = __webpack_require__(58);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }),\n\n/***/ 691:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(283);\nvar audit_1 = __webpack_require__(692);\nvar timer_1 = __webpack_require__(693);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 692:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(170);\nvar errorObject_1 = __webpack_require__(120);\nvar OuterSubscriber_1 = __webpack_require__(61);\nvar subscribeToResult_1 = __webpack_require__(60);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 693:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(694);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 694:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(289);\nvar Observable_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(283);\nvar isScheduler_1 = __webpack_require__(173);\nvar isDate_1 = __webpack_require__(695);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 695:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 696:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(283);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 697:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 2-4aeb54ad63fc47b95064.js","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar Platform = (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar PlatformModule = (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, supportsPassiveEventListeners, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { merge } from 'rxjs/observable/merge';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable.create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : of();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar CdkScrollable = (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar ScrollDispatchModule = (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [CdkScrollable],\n                    declarations: [CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, Input, NgModule, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = (function (_super) {\n    __extends(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = (function (_super) {\n    __extends(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar DomPortalOutlet = (function (_super) {\n    __extends(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar CdkPortal = (function (_super) {\n    __extends(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return CdkPortal;\n}(TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar CdkPortalOutlet = (function (_super) {\n    __extends(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: Input, args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: Input, args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [CdkPortal, CdkPortalOutlet],\n                    declarations: [CdkPortal, CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { __assign, __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { DOCUMENT } from '@angular/common';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached on scroll. */\n    /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this.disable();\n                    if (_this._overlayRef.hasAttached()) {\n                        _this._overlayRef.detach();\n                    }\n                });\n            });\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         */\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone); };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n        { type: NgZone, },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = __assign({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = __assign({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        this._ngZone.runOutsideAngular(function () {\n            requestAnimationFrame(function () {\n                if (_this._backdropElement) {\n                    _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n                }\n            });\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = fromEvent(this._document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT)\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayContainer],\n        /** @type {?} */ (DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: OverlayKeyboardDispatcher, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir, _document) {\n        var _this = this;\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._document = _document;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        /**\n         * Event listener that will close the overlay when the user presses escape.\n         */\n        this._escapeListener = function (event) {\n            if (event.keyCode === ESCAPE) {\n                _this._detachOverlay();\n            }\n        };\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        this._document.addEventListener('keydown', this._escapeListener);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._document.removeEventListener('keydown', this._escapeListener);\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._document.removeEventListener('keydown', this._escapeListener);\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: Input, args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: Input, args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: Input, args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: Input, args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: Input, args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: Input, args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: Input, args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: Input, args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: Input, args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: Input, args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: Input, args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: Input, args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: Output },],\n        \"positionChange\": [{ type: Output },],\n        \"attach\": [{ type: Output },],\n        \"detach\": [{ type: Output },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [BidiModule, PortalModule, ScrollDispatchModule],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],\n                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as g, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as f, OVERLAY_CONTAINER_PROVIDER as b, OVERLAY_CONTAINER_PROVIDER_FACTORY as a, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as c, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d, OverlayPositionBuilder as h };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { take } from 'rxjs/operators/take';\nimport { Platform, PlatformModule, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, NINE, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar FocusTrap = (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar FocusTrapDeprecatedDirective = (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: Input, args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar ListKeyManager = (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar ActiveDescendantKeyManager = (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar FocusKeyManager = (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof Renderer2)) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkTrapFocus as FocusTrapDirective, ActiveDescendantKeyManager, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, isFakeMousedownFromScreenReader, FocusKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, CdkTrapFocus, InteractivityChecker, ListKeyManager, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.crt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.vid(0, [(_l()(), i0.and(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"\\n            \"])), (_l()(), i0.and(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.did(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.pod(4, { $implicit: 0 }), (_l()(), i0.ted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.did(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.did(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), i0.qud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.eld(2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n        \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.did(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.nov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.nov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.nov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.nov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.nov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.did(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.crt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.vid(0, [i0.qud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.did(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i5 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i7 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i8 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i10 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i12 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i13 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i14 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i16 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i17 from \"../demo-utils/calendar-header.component\";\nimport * as i18 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i19 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i22 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.crt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.nov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.did(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i1.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ppd(3, 3), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.unv(_v, 2, 0, _ck(_v, 3, 0, i0.nov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_3)), i0.did(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ted(10, null, [\"\", \"\"])), i0.ppd(11, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_4)), i0.did(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.nov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.unv(_v, 10, 0, _ck(_v, 11, 0, i0.nov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.did(1, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ted(4, null, [\"\", \"\"])), i0.ppd(5, 3), (_l()(), i0.eld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n      \"])), (_l()(), i0.eld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ted(9, null, [\"\", \"\"])), i0.ppd(10, 3), (_l()(), i0.ted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.nov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.unv(_v, 4, 0, _ck(_v, 5, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.unv(_v, 9, 0, _ck(_v, 10, 0, i0.nov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_6)), i0.did(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.vid(0, [(_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.eld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.nov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.did(3, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n    \"])), (_l()(), i0.eld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ted(6, null, [\"\\n      \", \"\\n    \"])), i0.ppd(7, 3), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.nov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.unv(_v, 6, 0, _ck(_v, 7, 0, i0.nov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i5.View_CalendarMonthViewComponent_0, i5.RenderType_CalendarMonthViewComponent)), i0.did(1, 770048, null, 0, i6.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i8.View_CalendarWeekViewComponent_0, i8.RenderType_CalendarWeekViewComponent)), i0.did(1, 770048, null, 0, i9.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i10.View_CalendarDayViewComponent_0, i10.RenderType_CalendarDayViewComponent)), i0.did(1, 770048, null, 0, i11.CalendarDayViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.nov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.vid(2, [i0.pid(0, i12.CalendarDatePipe, [i13.CalendarDateFormatter, i0.LOCALE_ID]), i0.pid(0, i14.CalendarEventTitlePipe, [i15.CalendarEventTitleFormatter]), (_l()(), i0.eld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i16.View_CalendarHeaderComponent_0, i16.RenderType_CalendarHeaderComponent)), i0.did(3, 49152, null, 0, i17.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i18.View_ContextMenuComponent_0, i18.RenderType_ContextMenuComponent)), i0.did(7, 180224, [[\"basicMenu\", 4]], 1, i19.ContextMenuComponent, [i4.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i20.CONTEXT_MENU_OPTIONS]], null, null), i0.qud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.did(11, 16384, [[1, 4]], 0, i21.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ted(-1, null, [\"\\n\"])), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.and(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ted(-1, null, [\"\\n\\n\"])), (_l()(), i0.eld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.did(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_8)), i0.did(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_9)), i0.did(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n  \"])), (_l()(), i0.and(16777216, null, null, 1, null, View_DemoComponent_10)), i0.did(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.did(1, 49152, null, 0, i22.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ccf(\"mwl-demo-component\", i22.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar Dir = (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: Output, args: ['dirChange',] },],\n        \"dir\": [{ type: Input, args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar BidiModule = (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE, COMMA };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: Input },],\n        \"item\": [{ type: Input },],\n        \"event\": [{ type: Input },],\n        \"parentContextMenu\": [{ type: Input },],\n        \"overlay\": [{ type: Input },],\n        \"isLeaf\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n        \"openSubMenu\": [{ type: Output },],\n        \"closeLeafMenu\": [{ type: Output },],\n        \"closeAllMenus\": [{ type: Output },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n        \"menuItemElements\": [{ type: ViewChildren, args: ['li',] },],\n        \"onKeyEvent\": [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: Input },],\n        \"divider\": [{ type: Input },],\n        \"enabled\": [{ type: Input },],\n        \"passive\": [{ type: Input },],\n        \"visible\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","import { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: Input },],\n        \"useBootstrap4\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"close\": [{ type: Output },],\n        \"open\": [{ type: Output },],\n        \"menuItems\": [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: Input },],\n        \"contextMenu\": [{ type: Input },],\n        \"onContextMenu\": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/bidi\";\nimport * as i8 from \"@angular/cdk/platform\";\nimport * as i9 from \"@angular/cdk/scrolling\";\nimport * as i10 from \"@angular/cdk/overlay\";\nimport * as i11 from \"@angular/forms\";\nimport * as i12 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i13 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i17 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i18 from \"angular-draggable-droppable\";\nimport * as i19 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i23 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i24 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i25 from \"angular-resizable-element\";\nimport * as i26 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i27 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i28 from \"../../../src/modules/calendar.module\";\nimport * as i29 from \"@angular/cdk/portal\";\nimport * as i30 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i31 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i32 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i33 from \"../demo-utils/module\";\nimport * as i34 from \"@angular/router\";\nimport * as i35 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i36 from \"./component\";\nvar DemoModuleNgFactory = i0.cmf(i1.DemoModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.a]]), i0.mpd(6144, i7.DIR_DOCUMENT, null, [i6.DOCUMENT]), i0.mpd(4608, i7.Directionality, i7.Directionality, [[2, i7.DIR_DOCUMENT]]), i0.mpd(4608, i8.Platform, i8.Platform, []), i0.mpd(5120, i9.ScrollDispatcher, i9.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i9.ScrollDispatcher], i0.NgZone, i8.Platform]), i0.mpd(5120, i9.ViewportRuler, i9.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i9.ViewportRuler], i8.Platform, i0.NgZone]), i0.mpd(4608, i10.ScrollStrategyOptions, i10.ScrollStrategyOptions, [i9.ScrollDispatcher, i9.ViewportRuler, i0.NgZone]), i0.mpd(5120, i10.OverlayContainer, i10.a, [[3, i10.OverlayContainer], i6.DOCUMENT]), i0.mpd(4608, i10.h, i10.h, [i9.ViewportRuler, i6.DOCUMENT]), i0.mpd(5120, i10.OverlayKeyboardDispatcher, i10.f, [[3, i10.OverlayKeyboardDispatcher], i6.DOCUMENT]), i0.mpd(4608, i10.Overlay, i10.Overlay, [i10.ScrollStrategyOptions, i10.OverlayContainer, i0.ComponentFactoryResolver, i10.h, i10.OverlayKeyboardDispatcher, i0.ApplicationRef, i0.Injector, i0.NgZone, i6.DOCUMENT]), i0.mpd(5120, i10.c, i10.d, [i10.Overlay]), i0.mpd(4608, i11.i, i11.i, []), i0.mpd(4608, i12.NgbCalendar, i12.NgbCalendarGregorian, []), i0.mpd(4608, i13.NgbDatepickerI18n, i13.NgbDatepickerI18nDefault, []), i0.mpd(4608, i14.NgbDateParserFormatter, i14.NgbDateISOParserFormatter, []), i0.mpd(4608, i15.NgbDateAdapter, i15.NgbDateStructAdapter, []), i0.mpd(4608, i16.NgbDatepickerConfig, i16.NgbDatepickerConfig, []), i0.mpd(4608, i17.NgbTimepickerConfig, i17.NgbTimepickerConfig, []), i0.mpd(4608, i18.DraggableHelper, i18.DraggableHelper, []), i0.mpd(4608, i19.CalendarEventTitleFormatter, i19.CalendarEventTitleFormatter, []), i0.mpd(4608, i20.CalendarDateFormatter, i20.CalendarDateFormatter, []), i0.mpd(4608, i21.CalendarUtils, i21.CalendarUtils, []), i0.mpd(4608, i22.ContextMenuService, i22.ContextMenuService, [i10.Overlay, i10.ScrollStrategyOptions]), i0.mpd(512, i6.CommonModule, i6.CommonModule, []), i0.mpd(512, i23.CalendarCommonModule, i23.CalendarCommonModule, []), i0.mpd(512, i18.DragAndDropModule, i18.DragAndDropModule, []), i0.mpd(512, i24.CalendarMonthModule, i24.CalendarMonthModule, []), i0.mpd(512, i25.ResizableModule, i25.ResizableModule, []), i0.mpd(512, i26.CalendarWeekModule, i26.CalendarWeekModule, []), i0.mpd(512, i27.CalendarDayModule, i27.CalendarDayModule, []), i0.mpd(512, i28.CalendarModule, i28.CalendarModule, []), i0.mpd(512, i7.BidiModule, i7.BidiModule, []), i0.mpd(512, i29.PortalModule, i29.PortalModule, []), i0.mpd(512, i8.PlatformModule, i8.PlatformModule, []), i0.mpd(512, i9.ScrollDispatchModule, i9.ScrollDispatchModule, []), i0.mpd(512, i10.OverlayModule, i10.OverlayModule, []), i0.mpd(512, i30.ContextMenuModule, i30.ContextMenuModule, []), i0.mpd(512, i11.ba, i11.ba, []), i0.mpd(512, i11.FormsModule, i11.FormsModule, []), i0.mpd(512, i31.NgbDatepickerModule, i31.NgbDatepickerModule, []), i0.mpd(512, i32.NgbTimepickerModule, i32.NgbTimepickerModule, []), i0.mpd(512, i33.DemoUtilsModule, i33.DemoUtilsModule, []), i0.mpd(512, i34.RouterModule, i34.RouterModule, [[2, i34.a], [2, i34.Router]]), i0.mpd(512, i1.DemoModule, i1.DemoModule, []), i0.mpd(256, i35.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.mpd(1024, i34.ROUTES, function () { return [[{ path: \"\", component: i36.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/fromEvent.js\n// module id = 686\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromEventObservable.js\n// module id = 690\n// module chunks = 2","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 691\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 692\n// module chunks = 2","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 693\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 694\n// module chunks = 2","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 695\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 696\n// module chunks = 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 697\n// module chunks = 2"],"sourceRoot":""}